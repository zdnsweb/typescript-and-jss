<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="minimum-scale=1, initial-scale=1, width=device-width"/><meta name="theme-color" content="#1976d2"/><title class="jsx-cbfd42e26539136">Typescript and JSS</title><link rel="icon" href="/zdns.svg" class="jsx-cbfd42e26539136"/><meta name="next-head-count" content="5"/><meta name="theme-color" content="#90caf9"/><link rel="preload" href="/_next/static/css/ef46db3751d8e999.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ef46db3751d8e999.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-fcec467324f41dbb.js" defer=""></script><script src="/_next/static/chunks/framework-e70c6273bfe3f237.js" defer=""></script><script src="/_next/static/chunks/main-7c9e8fd8226b6573.js" defer=""></script><script src="/_next/static/chunks/pages/_app-0617cd64ea924586.js" defer=""></script><script src="/_next/static/chunks/505-0c2bccf53cd8dae5.js" defer=""></script><script src="/_next/static/chunks/pages/%5Brule%5D-b74fec192cf33e56.js" defer=""></script><script src="/_next/static/V190Mxkh11cN1_jT2mDz7/_buildManifest.js" defer=""></script><script src="/_next/static/V190Mxkh11cN1_jT2mDz7/_ssgManifest.js" defer=""></script><script src="/_next/static/V190Mxkh11cN1_jT2mDz7/_middlewareManifest.js" defer=""></script><style id="__jsx-4ab09977da39fd03">.container.jsx-cbfd42e26539136{min-height:100vh;padding:0 .5rem;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}main.jsx-cbfd42e26539136{padding:5rem 0;-webkit-flex:1;-ms-flex:1;flex:1;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}footer.jsx-cbfd42e26539136{width:100%;height:100px;border-top:1px solid#eaeaea;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}footer.jsx-cbfd42e26539136 img.jsx-cbfd42e26539136{margin-left:.5rem}footer.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}a.jsx-cbfd42e26539136{color:inherit;text-decoration:none}.title.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136{color:#0070f3;text-decoration:none}.title.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136:hover,.title.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136:focus,.title.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136:active{text-decoration:underline}.title.jsx-cbfd42e26539136{margin:0;line-height:1.15;font-size:4rem}.title.jsx-cbfd42e26539136,.description.jsx-cbfd42e26539136{text-align:center}.description.jsx-cbfd42e26539136{line-height:1.5;font-size:1.5rem}code.jsx-cbfd42e26539136{background:#fafafa;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px;padding:.75rem;font-size:1.1rem;font-family:Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace}.grid.jsx-cbfd42e26539136{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-justify-content:center;justify-content:center;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;max-width:800px;margin-top:3rem}.card.jsx-cbfd42e26539136{margin:1rem;-webkit-flex-basis:45%;-ms-flex-preferred-size:45%;flex-basis:45%;padding:1.5rem;text-align:left;color:inherit;text-decoration:none;border:1px solid#eaeaea;-webkit-border-radius:10px;-moz-border-radius:10px;border-radius:10px;-webkit-transition:color.15s ease,border-color.15s ease;-moz-transition:color.15s ease,border-color.15s ease;-o-transition:color.15s ease,border-color.15s ease;transition:color.15s ease,border-color.15s ease}.card.jsx-cbfd42e26539136:hover,.card.jsx-cbfd42e26539136:focus,.card.jsx-cbfd42e26539136:active{color:#0070f3;border-color:#0070f3}.card.jsx-cbfd42e26539136 h3.jsx-cbfd42e26539136{margin:0 0 1rem 0;font-size:1.5rem}.card.jsx-cbfd42e26539136 p.jsx-cbfd42e26539136{margin:0;font-size:1.25rem;line-height:1.5}.logo.jsx-cbfd42e26539136{height:1em}@media(max-width:600px){.grid.jsx-cbfd42e26539136{width:100%;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}}</style><style id="__jsx-5750d7069672f50d">html,body{padding:0;margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif}*{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}</style><style data-emotion="css "></style></head><body><div id="__next" data-reactroot=""><style data-emotion="css-global o6gwfi">html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;box-sizing:border-box;-webkit-text-size-adjust:100%;}*,*::before,*::after{box-sizing:inherit;}strong,b{font-weight:700;}body{margin:0;color:rgba(0, 0, 0, 0.87);font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;background-color:#fff;}@media print{body{background-color:#fff;}}body::backdrop{background-color:#fff;}</style><div class="jsx-cbfd42e26539136 container"><main class="jsx-cbfd42e26539136"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation1 css-aoeo82"><h1><code>prefer-nullish-coalescing</code></h1>
<p>Enforce the usage of the nullish coalescing operator instead of logical chaining.</p>
<p>TypeScript 3.7 added support for the nullish coalescing operator.
This operator allows you to safely cascade a value when dealing with <code>null</code> or <code>undefined</code>.</p>
<pre><code class="language-ts">function myFunc(foo: string | null) {
  return foo ?? &#x27;a string&#x27;;
}

// is equivalent to

function myFunc(foo: string | null) {
  return foo !== null &amp;&amp; foo !== undefined ? foo : &#x27;a string&#x27;;
}
</code></pre>
<p>Because the nullish coalescing operator <em>only</em> coalesces when the original value is <code>null</code> or <code>undefined</code>, it is much safer than relying upon logical OR operator chaining <code>||</code>; which coalesces on any <em>falsy</em> value:</p>
<pre><code class="language-ts">const emptyString = &#x27;&#x27;;

const nullish1 = emptyString ?? &#x27;unsafe&#x27;;
const logical1 = emptyString || &#x27;unsafe&#x27;;

// nullish1 === &#x27;&#x27;
// logical1 === &#x27;unsafe&#x27;

declare const nullString: string | null;

const nullish2 = nullString ?? &#x27;safe&#x27;;
const logical2 = nullString || &#x27;safe&#x27;;

// nullish2 === &#x27;safe&#x27;
// logical2 === &#x27;safe&#x27;
</code></pre>
<h2>Rule Details</h2>
<p>This rule aims enforce the usage of the safer operator.</p>
<h2>Options</h2>
<pre><code class="language-ts">type Options = [
  {
    ignoreConditionalTests?: boolean;
    ignoreMixedLogicalExpressions?: boolean;
  },
];

const defaultOptions = [
  {
    ignoreConditionalTests: true,
    ignoreMixedLogicalExpressions: true,
  },
];
</code></pre>
<h3><code>ignoreConditionalTests</code></h3>
<p>Setting this option to <code>true</code> (the default) will cause the rule to ignore any cases that are located within a conditional test.</p>
<p>Generally expressions within conditional tests intentionally use the falsy fallthrough behavior of the logical or operator, meaning that fixing the operator to the nullish coalesce operator could cause bugs.</p>
<p>If you&#x27;re looking to enforce stricter conditional tests, you should consider using the <code>strict-boolean-expressions</code> rule.</p>
<p>Incorrect code for <code>ignoreConditionalTests: false</code>, and correct code for <code>ignoreConditionalTests: true</code>:</p>
<pre><code class="language-ts">declare const a: string | null;
declare const b: string | null;

if (a || b) {
}
while (a || b) {}
do {} while (a || b);
for (let i = 0; a || b; i += 1) {}
a || b ? true : false;
</code></pre>
<p>Correct code for <code>ignoreConditionalTests: false</code>:</p>
<pre><code class="language-ts">declare const a: string | null;
declare const b: string | null;

if (a ?? b) {
}
while (a ?? b) {}
do {} while (a ?? b);
for (let i = 0; a ?? b; i += 1) {}
a ?? b ? true : false;
</code></pre>
<h3><code>ignoreMixedLogicalExpressions</code></h3>
<p>Setting this option to <code>true</code> (the default) will cause the rule to ignore any logical or expressions that are part of a mixed logical expression (with <code>&amp;&amp;</code>).</p>
<p>Generally expressions within mixed logical expressions intentionally use the falsy fallthrough behavior of the logical or operator, meaning that fixing the operator to the nullish coalesce operator could cause bugs.</p>
<p>If you&#x27;re looking to enforce stricter conditional tests, you should consider using the <code>strict-boolean-expressions</code> rule.</p>
<p>Incorrect code for <code>ignoreMixedLogicalExpressions: false</code>, and correct code for <code>ignoreMixedLogicalExpressions: true</code>:</p>
<pre><code class="language-ts">declare const a: string | null;
declare const b: string | null;
declare const c: string | null;
declare const d: string | null;

a || (b &amp;&amp; c);
(a &amp;&amp; b) || c || d;
a || (b &amp;&amp; c) || d;
a || (b &amp;&amp; c &amp;&amp; d);
</code></pre>
<p>Correct code for <code>ignoreMixedLogicalExpressions: false</code>:</p>
<pre><code class="language-ts">declare const a: string | null;
declare const b: string | null;
declare const c: string | null;
declare const d: string | null;

a ?? (b &amp;&amp; c);
(a &amp;&amp; b) ?? c ?? d;
a ?? (b &amp;&amp; c) ?? d;
a ?? (b &amp;&amp; c &amp;&amp; d);
</code></pre>
<p><strong><em>NOTE:</em></strong> Errors for this specific case will be presented as suggestions (see below), instead of fixes. This is because it is not always safe to automatically convert <code>||</code> to <code>??</code> within a mixed logical expression, as we cannot tell the intended precedence of the operator. Note that by design, <code>??</code> requires parentheses when used with <code>&amp;&amp;</code> or <code>||</code> in the same expression.</p>
<h2>When Not To Use It</h2>
<p>If you are not using TypeScript 3.7 (or greater), then you will not be able to use this rule, as the operator is not supported.</p>
<h2>Further Reading</h2>
<ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html">TypeScript 3.7 Release Notes</a></li>
<li><a href="https://github.com/tc39/proposal-nullish-coalescing/">Nullish Coalescing Operator Proposal</a></li>
</ul>
<h2>Attributes</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled=""/> <!-- -->✅ Recommended</li>
<li class="task-list-item"><input type="checkbox" disabled=""/> <!-- -->🔧 Fixable</li>
<li class="task-list-item"><input type="checkbox" checked="" disabled=""/> <!-- -->💭 Requires type information</li>
</ul></div></main><footer class="jsx-cbfd42e26539136"><a href="https://cloud.zdns.cn" target="_blank" rel="noopener noreferrer" class="jsx-cbfd42e26539136">Powered by <img src="/zdns.svg" alt="zdns" class="jsx-cbfd42e26539136 logo"/></a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"rule":"# `prefer-nullish-coalescing`\n\nEnforce the usage of the nullish coalescing operator instead of logical chaining.\n\nTypeScript 3.7 added support for the nullish coalescing operator.\nThis operator allows you to safely cascade a value when dealing with `null` or `undefined`.\n\n```ts\nfunction myFunc(foo: string | null) {\n  return foo ?? 'a string';\n}\n\n// is equivalent to\n\nfunction myFunc(foo: string | null) {\n  return foo !== null \u0026\u0026 foo !== undefined ? foo : 'a string';\n}\n```\n\nBecause the nullish coalescing operator _only_ coalesces when the original value is `null` or `undefined`, it is much safer than relying upon logical OR operator chaining `||`; which coalesces on any _falsy_ value:\n\n```ts\nconst emptyString = '';\n\nconst nullish1 = emptyString ?? 'unsafe';\nconst logical1 = emptyString || 'unsafe';\n\n// nullish1 === ''\n// logical1 === 'unsafe'\n\ndeclare const nullString: string | null;\n\nconst nullish2 = nullString ?? 'safe';\nconst logical2 = nullString || 'safe';\n\n// nullish2 === 'safe'\n// logical2 === 'safe'\n```\n\n## Rule Details\n\nThis rule aims enforce the usage of the safer operator.\n\n## Options\n\n```ts\ntype Options = [\n  {\n    ignoreConditionalTests?: boolean;\n    ignoreMixedLogicalExpressions?: boolean;\n  },\n];\n\nconst defaultOptions = [\n  {\n    ignoreConditionalTests: true,\n    ignoreMixedLogicalExpressions: true,\n  },\n];\n```\n\n### `ignoreConditionalTests`\n\nSetting this option to `true` (the default) will cause the rule to ignore any cases that are located within a conditional test.\n\nGenerally expressions within conditional tests intentionally use the falsy fallthrough behavior of the logical or operator, meaning that fixing the operator to the nullish coalesce operator could cause bugs.\n\nIf you're looking to enforce stricter conditional tests, you should consider using the `strict-boolean-expressions` rule.\n\nIncorrect code for `ignoreConditionalTests: false`, and correct code for `ignoreConditionalTests: true`:\n\n```ts\ndeclare const a: string | null;\ndeclare const b: string | null;\n\nif (a || b) {\n}\nwhile (a || b) {}\ndo {} while (a || b);\nfor (let i = 0; a || b; i += 1) {}\na || b ? true : false;\n```\n\nCorrect code for `ignoreConditionalTests: false`:\n\n```ts\ndeclare const a: string | null;\ndeclare const b: string | null;\n\nif (a ?? b) {\n}\nwhile (a ?? b) {}\ndo {} while (a ?? b);\nfor (let i = 0; a ?? b; i += 1) {}\na ?? b ? true : false;\n```\n\n### `ignoreMixedLogicalExpressions`\n\nSetting this option to `true` (the default) will cause the rule to ignore any logical or expressions that are part of a mixed logical expression (with `\u0026\u0026`).\n\nGenerally expressions within mixed logical expressions intentionally use the falsy fallthrough behavior of the logical or operator, meaning that fixing the operator to the nullish coalesce operator could cause bugs.\n\nIf you're looking to enforce stricter conditional tests, you should consider using the `strict-boolean-expressions` rule.\n\nIncorrect code for `ignoreMixedLogicalExpressions: false`, and correct code for `ignoreMixedLogicalExpressions: true`:\n\n```ts\ndeclare const a: string | null;\ndeclare const b: string | null;\ndeclare const c: string | null;\ndeclare const d: string | null;\n\na || (b \u0026\u0026 c);\n(a \u0026\u0026 b) || c || d;\na || (b \u0026\u0026 c) || d;\na || (b \u0026\u0026 c \u0026\u0026 d);\n```\n\nCorrect code for `ignoreMixedLogicalExpressions: false`:\n\n```ts\ndeclare const a: string | null;\ndeclare const b: string | null;\ndeclare const c: string | null;\ndeclare const d: string | null;\n\na ?? (b \u0026\u0026 c);\n(a \u0026\u0026 b) ?? c ?? d;\na ?? (b \u0026\u0026 c) ?? d;\na ?? (b \u0026\u0026 c \u0026\u0026 d);\n```\n\n**_NOTE:_** Errors for this specific case will be presented as suggestions (see below), instead of fixes. This is because it is not always safe to automatically convert `||` to `??` within a mixed logical expression, as we cannot tell the intended precedence of the operator. Note that by design, `??` requires parentheses when used with `\u0026\u0026` or `||` in the same expression.\n\n## When Not To Use It\n\nIf you are not using TypeScript 3.7 (or greater), then you will not be able to use this rule, as the operator is not supported.\n\n## Further Reading\n\n- [TypeScript 3.7 Release Notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html)\n- [Nullish Coalescing Operator Proposal](https://github.com/tc39/proposal-nullish-coalescing/)\n\n## Attributes\n\n- [ ] ✅ Recommended\n- [ ] 🔧 Fixable\n- [x] 💭 Requires type information\n"},"__N_SSG":true},"page":"/[rule]","query":{"rule":"prefer-nullish-coalescing.md"},"buildId":"V190Mxkh11cN1_jT2mDz7","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>