<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="minimum-scale=1, initial-scale=1, width=device-width"/><meta name="theme-color" content="#1976d2"/><title class="jsx-cbfd42e26539136">Typescript and JSS</title><link rel="icon" href="/zdns.svg" class="jsx-cbfd42e26539136"/><meta name="next-head-count" content="5"/><meta name="theme-color" content="#90caf9"/><link rel="preload" href="/_next/static/css/ef46db3751d8e999.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ef46db3751d8e999.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-fcec467324f41dbb.js" defer=""></script><script src="/_next/static/chunks/framework-e70c6273bfe3f237.js" defer=""></script><script src="/_next/static/chunks/main-7c9e8fd8226b6573.js" defer=""></script><script src="/_next/static/chunks/pages/_app-0617cd64ea924586.js" defer=""></script><script src="/_next/static/chunks/505-0c2bccf53cd8dae5.js" defer=""></script><script src="/_next/static/chunks/pages/%5Brule%5D-b74fec192cf33e56.js" defer=""></script><script src="/_next/static/V190Mxkh11cN1_jT2mDz7/_buildManifest.js" defer=""></script><script src="/_next/static/V190Mxkh11cN1_jT2mDz7/_ssgManifest.js" defer=""></script><script src="/_next/static/V190Mxkh11cN1_jT2mDz7/_middlewareManifest.js" defer=""></script><style id="__jsx-4ab09977da39fd03">.container.jsx-cbfd42e26539136{min-height:100vh;padding:0 .5rem;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}main.jsx-cbfd42e26539136{padding:5rem 0;-webkit-flex:1;-ms-flex:1;flex:1;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}footer.jsx-cbfd42e26539136{width:100%;height:100px;border-top:1px solid#eaeaea;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}footer.jsx-cbfd42e26539136 img.jsx-cbfd42e26539136{margin-left:.5rem}footer.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}a.jsx-cbfd42e26539136{color:inherit;text-decoration:none}.title.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136{color:#0070f3;text-decoration:none}.title.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136:hover,.title.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136:focus,.title.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136:active{text-decoration:underline}.title.jsx-cbfd42e26539136{margin:0;line-height:1.15;font-size:4rem}.title.jsx-cbfd42e26539136,.description.jsx-cbfd42e26539136{text-align:center}.description.jsx-cbfd42e26539136{line-height:1.5;font-size:1.5rem}code.jsx-cbfd42e26539136{background:#fafafa;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px;padding:.75rem;font-size:1.1rem;font-family:Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace}.grid.jsx-cbfd42e26539136{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-justify-content:center;justify-content:center;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;max-width:800px;margin-top:3rem}.card.jsx-cbfd42e26539136{margin:1rem;-webkit-flex-basis:45%;-ms-flex-preferred-size:45%;flex-basis:45%;padding:1.5rem;text-align:left;color:inherit;text-decoration:none;border:1px solid#eaeaea;-webkit-border-radius:10px;-moz-border-radius:10px;border-radius:10px;-webkit-transition:color.15s ease,border-color.15s ease;-moz-transition:color.15s ease,border-color.15s ease;-o-transition:color.15s ease,border-color.15s ease;transition:color.15s ease,border-color.15s ease}.card.jsx-cbfd42e26539136:hover,.card.jsx-cbfd42e26539136:focus,.card.jsx-cbfd42e26539136:active{color:#0070f3;border-color:#0070f3}.card.jsx-cbfd42e26539136 h3.jsx-cbfd42e26539136{margin:0 0 1rem 0;font-size:1.5rem}.card.jsx-cbfd42e26539136 p.jsx-cbfd42e26539136{margin:0;font-size:1.25rem;line-height:1.5}.logo.jsx-cbfd42e26539136{height:1em}@media(max-width:600px){.grid.jsx-cbfd42e26539136{width:100%;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}}</style><style id="__jsx-5750d7069672f50d">html,body{padding:0;margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif}*{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}</style><style data-emotion="css "></style></head><body><div id="__next" data-reactroot=""><style data-emotion="css-global o6gwfi">html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;box-sizing:border-box;-webkit-text-size-adjust:100%;}*,*::before,*::after{box-sizing:inherit;}strong,b{font-weight:700;}body{margin:0;color:rgba(0, 0, 0, 0.87);font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;background-color:#fff;}@media print{body{background-color:#fff;}}body::backdrop{background-color:#fff;}</style><div class="jsx-cbfd42e26539136 container"><main class="jsx-cbfd42e26539136"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation1 css-aoeo82"><h1><code>consistent-type-assertions</code></h1>
<p>Enforces consistent usage of type assertions.</p>
<h2>Rule Details</h2>
<p>This rule aims to standardize the use of type assertion style across the codebase.</p>
<p>Type assertions are also commonly referred as &quot;type casting&quot; in TypeScript (even though it is technically slightly different to what is understood by type casting in other languages), so you can think of type assertions and type casting referring to the same thing. It is essentially you saying to the TypeScript compiler, &quot;in this case, I know better than you!&quot;.</p>
<p>In addition to ensuring that type assertions are written in a consistent way, this rule also helps make your codebase more type-safe.</p>
<p><code>const</code> assertions, <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions">introduced in TypeScript 3.4</a>, is always allowed by this rule. Examples of it include <code>let x = &quot;hello&quot; as const;</code> and <code>let x = &lt;const&gt;&quot;hello&quot;;</code>.</p>
<h2>Options</h2>
<pre><code class="language-ts">type Options =
  | {
      assertionStyle: &#x27;as&#x27; | &#x27;angle-bracket&#x27;;
      objectLiteralTypeAssertions: &#x27;allow&#x27; | &#x27;allow-as-parameter&#x27; | &#x27;never&#x27;;
    }
  | {
      assertionStyle: &#x27;never&#x27;;
    };

const defaultOptions: Options = {
  assertionStyle: &#x27;as&#x27;,
  objectLiteralTypeAssertions: &#x27;allow&#x27;,
};
</code></pre>
<h3><code>assertionStyle</code></h3>
<p>This option defines the expected assertion style. Valid values for <code>assertionStyle</code> are:</p>
<ul>
<li><code>as</code> will enforce that you always use <code>... as foo</code>.</li>
<li><code>angle-bracket</code> will enforce that you always use <code>&lt;foo&gt;...</code></li>
<li><code>never</code> will enforce that you do not do any type assertions.</li>
</ul>
<p>Most codebases will want to enforce not using <code>angle-bracket</code> style because it conflicts with JSX syntax, and is confusing when paired with generic syntax.</p>
<p>Some codebases like to go for an extra level of type safety, and ban assertions altogether via the <code>never</code> option.</p>
<h3><code>objectLiteralTypeAssertions</code></h3>
<p>Always prefer <code>const x: T = { ... };</code> to <code>const x = { ... } as T;</code> (or similar with angle brackets). The type assertion in the latter case is either unnecessary or will probably hide an error.</p>
<p>The compiler will warn for excess properties with this syntax, but not missing <em>required</em> fields. For example: <code>const x: { foo: number } = {};</code> will fail to compile, but <code>const x = {} as { foo: number }</code> will succeed.</p>
<p>The const assertion <code>const x = { foo: 1 } as const</code>, introduced in TypeScript 3.4, is considered beneficial and is ignored by this option.</p>
<p>Assertions to <code>any</code> are also ignored by this option.</p>
<p>Examples of code for <code>{ assertionStyle: &#x27;as&#x27;, objectLiteralTypeAssertions: &#x27;never&#x27; }</code></p>
<!-- -->&lt;!--tabs--&gt;<!-- -->
<h4>❌ Incorrect</h4>
<pre><code class="language-ts">const x = { ... } as T;

function foo() {
  return { ... } as T;
}
</code></pre>
<h4>✅ Correct</h4>
<pre><code class="language-ts">const x: T = { ... };
const y = { ... } as any;
const z = { ... } as unknown;

function foo(): T {
  return { ... };
}
</code></pre>
<!-- -->&lt;!--/tabs--&gt;<!-- -->
<p>Examples of code for <code>{ assertionStyle: &#x27;as&#x27;, objectLiteralTypeAssertions: &#x27;allow-as-parameter&#x27; }</code></p>
<!-- -->&lt;!--tabs--&gt;<!-- -->
<h4>❌ Incorrect</h4>
<pre><code class="language-ts">const x = { ... } as T;

function foo() {
  return { ... } as T;
}
</code></pre>
<h4>✅ Correct</h4>
<pre><code class="language-tsx">const x: T = { ... };
const y = { ... } as any;
const z = { ... } as unknown;
foo({ ... } as T);
new Clazz({ ... } as T);
function foo() { throw { bar: 5 } as Foo }
const foo = &lt;Foo props={{ ... } as Bar}/&gt;;
</code></pre>
<!-- -->&lt;!--/tabs--&gt;<!-- -->
<h2>When Not To Use It</h2>
<p>If you do not want to enforce consistent type assertions.</p>
<h2>Related To</h2>
<ul>
<li>TSLint: <a href="https://palantir.github.io/tslint/rules/no-angle-bracket-type-assertion/">no-angle-bracket-type-assertion</a></li>
<li>TSLint: <a href="https://palantir.github.io/tslint/rules/no-object-literal-type-assertion/">no-object-literal-type-assertion</a></li>
</ul>
<h2>Attributes</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled=""/> <!-- -->✅ Recommended</li>
<li class="task-list-item"><input type="checkbox" disabled=""/> <!-- -->🔧 Fixable</li>
<li class="task-list-item"><input type="checkbox" disabled=""/> <!-- -->💭 Requires type information</li>
</ul></div></main><footer class="jsx-cbfd42e26539136"><a href="https://cloud.zdns.cn" target="_blank" rel="noopener noreferrer" class="jsx-cbfd42e26539136">Powered by <img src="/zdns.svg" alt="zdns" class="jsx-cbfd42e26539136 logo"/></a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"rule":"# `consistent-type-assertions`\n\nEnforces consistent usage of type assertions.\n\n## Rule Details\n\nThis rule aims to standardize the use of type assertion style across the codebase.\n\nType assertions are also commonly referred as \"type casting\" in TypeScript (even though it is technically slightly different to what is understood by type casting in other languages), so you can think of type assertions and type casting referring to the same thing. It is essentially you saying to the TypeScript compiler, \"in this case, I know better than you!\".\n\nIn addition to ensuring that type assertions are written in a consistent way, this rule also helps make your codebase more type-safe.\n\n`const` assertions, [introduced in TypeScript 3.4](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions), is always allowed by this rule. Examples of it include `let x = \"hello\" as const;` and `let x = \u003cconst\u003e\"hello\";`.\n\n## Options\n\n```ts\ntype Options =\n  | {\n      assertionStyle: 'as' | 'angle-bracket';\n      objectLiteralTypeAssertions: 'allow' | 'allow-as-parameter' | 'never';\n    }\n  | {\n      assertionStyle: 'never';\n    };\n\nconst defaultOptions: Options = {\n  assertionStyle: 'as',\n  objectLiteralTypeAssertions: 'allow',\n};\n```\n\n### `assertionStyle`\n\nThis option defines the expected assertion style. Valid values for `assertionStyle` are:\n\n- `as` will enforce that you always use `... as foo`.\n- `angle-bracket` will enforce that you always use `\u003cfoo\u003e...`\n- `never` will enforce that you do not do any type assertions.\n\nMost codebases will want to enforce not using `angle-bracket` style because it conflicts with JSX syntax, and is confusing when paired with generic syntax.\n\nSome codebases like to go for an extra level of type safety, and ban assertions altogether via the `never` option.\n\n### `objectLiteralTypeAssertions`\n\nAlways prefer `const x: T = { ... };` to `const x = { ... } as T;` (or similar with angle brackets). The type assertion in the latter case is either unnecessary or will probably hide an error.\n\nThe compiler will warn for excess properties with this syntax, but not missing _required_ fields. For example: `const x: { foo: number } = {};` will fail to compile, but `const x = {} as { foo: number }` will succeed.\n\nThe const assertion `const x = { foo: 1 } as const`, introduced in TypeScript 3.4, is considered beneficial and is ignored by this option.\n\nAssertions to `any` are also ignored by this option.\n\nExamples of code for `{ assertionStyle: 'as', objectLiteralTypeAssertions: 'never' }`\n\n\u003c!--tabs--\u003e\n\n#### ❌ Incorrect\n\n```ts\nconst x = { ... } as T;\n\nfunction foo() {\n  return { ... } as T;\n}\n```\n\n#### ✅ Correct\n\n```ts\nconst x: T = { ... };\nconst y = { ... } as any;\nconst z = { ... } as unknown;\n\nfunction foo(): T {\n  return { ... };\n}\n```\n\n\u003c!--/tabs--\u003e\n\nExamples of code for `{ assertionStyle: 'as', objectLiteralTypeAssertions: 'allow-as-parameter' }`\n\n\u003c!--tabs--\u003e\n\n#### ❌ Incorrect\n\n```ts\nconst x = { ... } as T;\n\nfunction foo() {\n  return { ... } as T;\n}\n```\n\n#### ✅ Correct\n\n```tsx\nconst x: T = { ... };\nconst y = { ... } as any;\nconst z = { ... } as unknown;\nfoo({ ... } as T);\nnew Clazz({ ... } as T);\nfunction foo() { throw { bar: 5 } as Foo }\nconst foo = \u003cFoo props={{ ... } as Bar}/\u003e;\n```\n\n\u003c!--/tabs--\u003e\n\n## When Not To Use It\n\nIf you do not want to enforce consistent type assertions.\n\n## Related To\n\n- TSLint: [no-angle-bracket-type-assertion](https://palantir.github.io/tslint/rules/no-angle-bracket-type-assertion/)\n- TSLint: [no-object-literal-type-assertion](https://palantir.github.io/tslint/rules/no-object-literal-type-assertion/)\n\n## Attributes\n\n- [ ] ✅ Recommended\n- [ ] 🔧 Fixable\n- [ ] 💭 Requires type information\n"},"__N_SSG":true},"page":"/[rule]","query":{"rule":"consistent-type-assertions.md"},"buildId":"V190Mxkh11cN1_jT2mDz7","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>