<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="minimum-scale=1, initial-scale=1, width=device-width"/><meta name="theme-color" content="#1976d2"/><title class="jsx-cbfd42e26539136">Typescript and JSS</title><link rel="icon" href="/zdns.svg" class="jsx-cbfd42e26539136"/><meta name="next-head-count" content="5"/><meta name="theme-color" content="#90caf9"/><link rel="preload" href="/_next/static/css/ef46db3751d8e999.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ef46db3751d8e999.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-fcec467324f41dbb.js" defer=""></script><script src="/_next/static/chunks/framework-e70c6273bfe3f237.js" defer=""></script><script src="/_next/static/chunks/main-7c9e8fd8226b6573.js" defer=""></script><script src="/_next/static/chunks/pages/_app-0617cd64ea924586.js" defer=""></script><script src="/_next/static/chunks/505-0c2bccf53cd8dae5.js" defer=""></script><script src="/_next/static/chunks/pages/%5Brule%5D-b74fec192cf33e56.js" defer=""></script><script src="/_next/static/V190Mxkh11cN1_jT2mDz7/_buildManifest.js" defer=""></script><script src="/_next/static/V190Mxkh11cN1_jT2mDz7/_ssgManifest.js" defer=""></script><script src="/_next/static/V190Mxkh11cN1_jT2mDz7/_middlewareManifest.js" defer=""></script><style id="__jsx-4ab09977da39fd03">.container.jsx-cbfd42e26539136{min-height:100vh;padding:0 .5rem;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}main.jsx-cbfd42e26539136{padding:5rem 0;-webkit-flex:1;-ms-flex:1;flex:1;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}footer.jsx-cbfd42e26539136{width:100%;height:100px;border-top:1px solid#eaeaea;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}footer.jsx-cbfd42e26539136 img.jsx-cbfd42e26539136{margin-left:.5rem}footer.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}a.jsx-cbfd42e26539136{color:inherit;text-decoration:none}.title.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136{color:#0070f3;text-decoration:none}.title.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136:hover,.title.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136:focus,.title.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136:active{text-decoration:underline}.title.jsx-cbfd42e26539136{margin:0;line-height:1.15;font-size:4rem}.title.jsx-cbfd42e26539136,.description.jsx-cbfd42e26539136{text-align:center}.description.jsx-cbfd42e26539136{line-height:1.5;font-size:1.5rem}code.jsx-cbfd42e26539136{background:#fafafa;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px;padding:.75rem;font-size:1.1rem;font-family:Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace}.grid.jsx-cbfd42e26539136{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-justify-content:center;justify-content:center;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;max-width:800px;margin-top:3rem}.card.jsx-cbfd42e26539136{margin:1rem;-webkit-flex-basis:45%;-ms-flex-preferred-size:45%;flex-basis:45%;padding:1.5rem;text-align:left;color:inherit;text-decoration:none;border:1px solid#eaeaea;-webkit-border-radius:10px;-moz-border-radius:10px;border-radius:10px;-webkit-transition:color.15s ease,border-color.15s ease;-moz-transition:color.15s ease,border-color.15s ease;-o-transition:color.15s ease,border-color.15s ease;transition:color.15s ease,border-color.15s ease}.card.jsx-cbfd42e26539136:hover,.card.jsx-cbfd42e26539136:focus,.card.jsx-cbfd42e26539136:active{color:#0070f3;border-color:#0070f3}.card.jsx-cbfd42e26539136 h3.jsx-cbfd42e26539136{margin:0 0 1rem 0;font-size:1.5rem}.card.jsx-cbfd42e26539136 p.jsx-cbfd42e26539136{margin:0;font-size:1.25rem;line-height:1.5}.logo.jsx-cbfd42e26539136{height:1em}@media(max-width:600px){.grid.jsx-cbfd42e26539136{width:100%;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}}</style><style id="__jsx-5750d7069672f50d">html,body{padding:0;margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif}*{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}</style><style data-emotion="css "></style></head><body><div id="__next" data-reactroot=""><style data-emotion="css-global o6gwfi">html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;box-sizing:border-box;-webkit-text-size-adjust:100%;}*,*::before,*::after{box-sizing:inherit;}strong,b{font-weight:700;}body{margin:0;color:rgba(0, 0, 0, 0.87);font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;background-color:#fff;}@media print{body{background-color:#fff;}}body::backdrop{background-color:#fff;}</style><div class="jsx-cbfd42e26539136 container"><main class="jsx-cbfd42e26539136"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation1 css-aoeo82"><h1><code>prefer-readonly-parameter-types</code></h1>
<p>Requires that function parameters are typed as readonly to prevent accidental mutation of inputs.</p>
<p>Mutating function arguments can lead to confusing, hard to debug behavior.
Whilst it&#x27;s easy to implicitly remember to not modify function arguments, explicitly typing arguments as readonly provides clear contract to consumers.
This contract makes it easier for a consumer to reason about if a function has side-effects.</p>
<h2>Rule Details</h2>
<p>This rule allows you to enforce that function parameters resolve to readonly types.
A type is considered readonly if:</p>
<ul>
<li>it is a primitive type (<code>string</code>, <code>number</code>, <code>boolean</code>, <code>symbol</code>, or an enum),</li>
<li>it is a function signature type,</li>
<li>it is a readonly array type whose element type is considered readonly.</li>
<li>it is a readonly tuple type whose elements are all considered readonly.</li>
<li>it is an object type whose properties are all marked as readonly, and whose values are all considered readonly.</li>
</ul>
<p>Examples of code for this rule:</p>
<!-- -->&lt;!--tabs--&gt;<!-- -->
<h3>❌ Incorrect</h3>
<pre><code class="language-ts">function array1(arg: string[]) {} // array is not readonly
function array2(arg: readonly string[][]) {} // array element is not readonly
function array3(arg: [string, number]) {} // tuple is not readonly
function array4(arg: readonly [string[], number]) {} // tuple element is not readonly
// the above examples work the same if you use ReadonlyArray&lt;T&gt; instead

function object1(arg: { prop: string }) {} // property is not readonly
function object2(arg: { readonly prop: string; prop2: string }) {} // not all properties are readonly
function object3(arg: { readonly prop: { prop2: string } }) {} // nested property is not readonly
// the above examples work the same if you use Readonly&lt;T&gt; instead

interface CustomArrayType extends ReadonlyArray&lt;string&gt; {
  prop: string; // note: this property is mutable
}
function custom1(arg: CustomArrayType) {}

interface CustomFunction {
  (): void;
  prop: string; // note: this property is mutable
}
function custom2(arg: CustomFunction) {}

function union(arg: string[] | ReadonlyArray&lt;number[]&gt;) {} // not all types are readonly

// rule also checks function types
interface Foo {
  (arg: string[]): void;
}
interface Foo {
  new (arg: string[]): void;
}
const x = { foo(arg: string[]): void; };
function foo(arg: string[]);
type Foo = (arg: string[]) =&gt; void;
interface Foo {
  foo(arg: string[]): void;
}
</code></pre>
<h3>✅ Correct</h3>
<pre><code class="language-ts">function array1(arg: readonly string[]) {}
function array2(arg: readonly (readonly string[])[]) {}
function array3(arg: readonly [string, number]) {}
function array4(arg: readonly [readonly string[], number]) {}
// the above examples work the same if you use ReadonlyArray&lt;T&gt; instead

function object1(arg: { readonly prop: string }) {}
function object2(arg: { readonly prop: string; readonly prop2: string }) {}
function object3(arg: { readonly prop: { readonly prop2: string } }) {}
// the above examples work the same if you use Readonly&lt;T&gt; instead

interface CustomArrayType extends ReadonlyArray&lt;string&gt; {
  readonly prop: string;
}
function custom1(arg: Readonly&lt;CustomArrayType&gt;) {}
// interfaces that extend the array types are not considered arrays, and thus must be made readonly.

interface CustomFunction {
  (): void;
  readonly prop: string;
}
function custom2(arg: CustomFunction) {}

function union(arg: readonly string[] | ReadonlyArray&lt;number[]&gt;) {}

function primitive1(arg: string) {}
function primitive2(arg: number) {}
function primitive3(arg: boolean) {}
function primitive4(arg: unknown) {}
function primitive5(arg: null) {}
function primitive6(arg: undefined) {}
function primitive7(arg: any) {}
function primitive8(arg: never) {}
function primitive9(arg: string | number | undefined) {}

function fnSig(arg: () =&gt; void) {}

enum Foo { a, b }
function enum(arg: Foo) {}

function symb1(arg: symbol) {}
const customSymbol = Symbol(&#x27;a&#x27;);
function symb2(arg: typeof customSymbol) {}

// function types
interface Foo {
  (arg: readonly string[]): void;
}
interface Foo {
  new (arg: readonly string[]): void;
}
const x = { foo(arg: readonly string[]): void; };
function foo(arg: readonly string[]);
type Foo = (arg: readonly string[]) =&gt; void;
interface Foo {
  foo(arg: readonly string[]): void;
}
</code></pre>
<h2>Options</h2>
<pre><code class="language-ts">interface Options {
  checkParameterProperties?: boolean;
  ignoreInferredTypes?: boolean;
}

const defaultOptions: Options = {
  checkParameterProperties: true,
  ignoreInferredTypes: false,
  treatMethodsAsReadonly: false,
};
</code></pre>
<h3><code>checkParameterProperties</code></h3>
<p>This option allows you to enable or disable the checking of parameter properties.
Because parameter properties create properties on the class, it may be undesirable to force them to be readonly.</p>
<p>Examples of code for this rule with <code>{checkParameterProperties: true}</code>:</p>
<!-- -->&lt;!--tabs--&gt;<!-- -->
<h4>❌ Incorrect</h4>
<pre><code class="language-ts">class Foo {
  constructor(private paramProp: string[]) {}
}
</code></pre>
<h4>✅ Correct</h4>
<pre><code class="language-ts">class Foo {
  constructor(private paramProp: readonly string[]) {}
}
</code></pre>
<!-- -->&lt;!--/tabs--&gt;<!-- -->
<p>Examples of <strong>correct</strong> code for this rule with <code>{checkParameterProperties: false}</code>:</p>
<pre><code class="language-ts">class Foo {
  constructor(
    private paramProp1: string[],
    private paramProp2: readonly string[],
  ) {}
}
</code></pre>
<h3><code>ignoreInferredTypes</code></h3>
<p>This option allows you to ignore parameters which don&#x27;t explicitly specify a type. This may be desirable in cases where an external dependency specifies a callback with mutable parameters, and manually annotating the callback&#x27;s parameters is undesirable.</p>
<p>Examples of code for this rule with <code>{ignoreInferredTypes: true}</code>:</p>
<!-- -->&lt;!--tabs--&gt;<!-- -->
<h4>❌ Incorrect</h4>
<pre><code class="language-ts">import { acceptsCallback, CallbackOptions } from &#x27;external-dependency&#x27;;

acceceptsCallback((options: CallbackOptions) =&gt; {});
</code></pre>
<!-- -->&lt;details&gt;
&lt;summary&gt;external-dependency.d.ts&lt;/summary&gt;<!-- -->
<pre><code class="language-ts">export interface CallbackOptions {
  prop: string;
}
type Callback = (options: CallbackOptions) =&gt; void;
type AcceptsCallback = (callback: Callback) =&gt; void;

export const acceptsCallback: AcceptsCallback;
</code></pre>
<!-- -->&lt;/details&gt;<!-- -->
<h4>✅ Correct</h4>
<pre><code class="language-ts">import { acceptsCallback } from &#x27;external-dependency&#x27;;

acceceptsCallback(options =&gt; {});
</code></pre>
<!-- -->&lt;details&gt;
&lt;summary&gt;external-dependency.d.ts&lt;/summary&gt;<!-- -->
<pre><code class="language-ts">export interface CallbackOptions {
  prop: string;
}
type Callback = (options: CallbackOptions) =&gt; void;
type AcceptsCallback = (callback: Callback) =&gt; void;

export const acceptsCallback: AcceptsCallback;
</code></pre>
<!-- -->&lt;/details&gt;<!-- -->
<h3><code>treatMethodsAsReadonly</code></h3>
<p>This option allows you to treat all mutable methods as though they were readonly. This may be desirable in when you are never reassigning methods.</p>
<p>Examples of code for this rule with <code>{treatMethodsAsReadonly: false}</code>:</p>
<!-- -->&lt;!--tabs--&gt;<!-- -->
<h4>❌ Incorrect</h4>
<pre><code class="language-ts">type MyType = {
  readonly prop: string;
  method(): string; // note: this method is mutable
};
function foo(arg: MyType) {}
</code></pre>
<h4>✅ Correct</h4>
<pre><code class="language-ts">type MyType = Readonly&lt;{
  prop: string;
  method(): string;
}&gt;;
function foo(arg: MyType) {}

type MyOtherType = {
  readonly prop: string;
  readonly method: () =&gt; string;
};
function bar(arg: MyOtherType) {}
</code></pre>
<!-- -->&lt;!--/tabs--&gt;<!-- -->
<p>Examples of <strong>correct</strong> code for this rule with <code>{treatMethodsAsReadonly: true}</code>:</p>
<pre><code class="language-ts">type MyType = {
  readonly prop: string;
  method(): string; // note: this method is mutable
};
function foo(arg: MyType) {}
</code></pre>
<h2>Attributes</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled=""/> <!-- -->✅ Recommended</li>
<li class="task-list-item"><input type="checkbox" disabled=""/> <!-- -->🔧 Fixable</li>
<li class="task-list-item"><input type="checkbox" checked="" disabled=""/> <!-- -->💭 Requires type information</li>
</ul></div></main><footer class="jsx-cbfd42e26539136"><a href="https://cloud.zdns.cn" target="_blank" rel="noopener noreferrer" class="jsx-cbfd42e26539136">Powered by <img src="/zdns.svg" alt="zdns" class="jsx-cbfd42e26539136 logo"/></a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"rule":"# `prefer-readonly-parameter-types`\n\nRequires that function parameters are typed as readonly to prevent accidental mutation of inputs.\n\nMutating function arguments can lead to confusing, hard to debug behavior.\nWhilst it's easy to implicitly remember to not modify function arguments, explicitly typing arguments as readonly provides clear contract to consumers.\nThis contract makes it easier for a consumer to reason about if a function has side-effects.\n\n## Rule Details\n\nThis rule allows you to enforce that function parameters resolve to readonly types.\nA type is considered readonly if:\n\n- it is a primitive type (`string`, `number`, `boolean`, `symbol`, or an enum),\n- it is a function signature type,\n- it is a readonly array type whose element type is considered readonly.\n- it is a readonly tuple type whose elements are all considered readonly.\n- it is an object type whose properties are all marked as readonly, and whose values are all considered readonly.\n\nExamples of code for this rule:\n\n\u003c!--tabs--\u003e\n\n### ❌ Incorrect\n\n```ts\nfunction array1(arg: string[]) {} // array is not readonly\nfunction array2(arg: readonly string[][]) {} // array element is not readonly\nfunction array3(arg: [string, number]) {} // tuple is not readonly\nfunction array4(arg: readonly [string[], number]) {} // tuple element is not readonly\n// the above examples work the same if you use ReadonlyArray\u003cT\u003e instead\n\nfunction object1(arg: { prop: string }) {} // property is not readonly\nfunction object2(arg: { readonly prop: string; prop2: string }) {} // not all properties are readonly\nfunction object3(arg: { readonly prop: { prop2: string } }) {} // nested property is not readonly\n// the above examples work the same if you use Readonly\u003cT\u003e instead\n\ninterface CustomArrayType extends ReadonlyArray\u003cstring\u003e {\n  prop: string; // note: this property is mutable\n}\nfunction custom1(arg: CustomArrayType) {}\n\ninterface CustomFunction {\n  (): void;\n  prop: string; // note: this property is mutable\n}\nfunction custom2(arg: CustomFunction) {}\n\nfunction union(arg: string[] | ReadonlyArray\u003cnumber[]\u003e) {} // not all types are readonly\n\n// rule also checks function types\ninterface Foo {\n  (arg: string[]): void;\n}\ninterface Foo {\n  new (arg: string[]): void;\n}\nconst x = { foo(arg: string[]): void; };\nfunction foo(arg: string[]);\ntype Foo = (arg: string[]) =\u003e void;\ninterface Foo {\n  foo(arg: string[]): void;\n}\n```\n\n### ✅ Correct\n\n```ts\nfunction array1(arg: readonly string[]) {}\nfunction array2(arg: readonly (readonly string[])[]) {}\nfunction array3(arg: readonly [string, number]) {}\nfunction array4(arg: readonly [readonly string[], number]) {}\n// the above examples work the same if you use ReadonlyArray\u003cT\u003e instead\n\nfunction object1(arg: { readonly prop: string }) {}\nfunction object2(arg: { readonly prop: string; readonly prop2: string }) {}\nfunction object3(arg: { readonly prop: { readonly prop2: string } }) {}\n// the above examples work the same if you use Readonly\u003cT\u003e instead\n\ninterface CustomArrayType extends ReadonlyArray\u003cstring\u003e {\n  readonly prop: string;\n}\nfunction custom1(arg: Readonly\u003cCustomArrayType\u003e) {}\n// interfaces that extend the array types are not considered arrays, and thus must be made readonly.\n\ninterface CustomFunction {\n  (): void;\n  readonly prop: string;\n}\nfunction custom2(arg: CustomFunction) {}\n\nfunction union(arg: readonly string[] | ReadonlyArray\u003cnumber[]\u003e) {}\n\nfunction primitive1(arg: string) {}\nfunction primitive2(arg: number) {}\nfunction primitive3(arg: boolean) {}\nfunction primitive4(arg: unknown) {}\nfunction primitive5(arg: null) {}\nfunction primitive6(arg: undefined) {}\nfunction primitive7(arg: any) {}\nfunction primitive8(arg: never) {}\nfunction primitive9(arg: string | number | undefined) {}\n\nfunction fnSig(arg: () =\u003e void) {}\n\nenum Foo { a, b }\nfunction enum(arg: Foo) {}\n\nfunction symb1(arg: symbol) {}\nconst customSymbol = Symbol('a');\nfunction symb2(arg: typeof customSymbol) {}\n\n// function types\ninterface Foo {\n  (arg: readonly string[]): void;\n}\ninterface Foo {\n  new (arg: readonly string[]): void;\n}\nconst x = { foo(arg: readonly string[]): void; };\nfunction foo(arg: readonly string[]);\ntype Foo = (arg: readonly string[]) =\u003e void;\ninterface Foo {\n  foo(arg: readonly string[]): void;\n}\n```\n\n## Options\n\n```ts\ninterface Options {\n  checkParameterProperties?: boolean;\n  ignoreInferredTypes?: boolean;\n}\n\nconst defaultOptions: Options = {\n  checkParameterProperties: true,\n  ignoreInferredTypes: false,\n  treatMethodsAsReadonly: false,\n};\n```\n\n### `checkParameterProperties`\n\nThis option allows you to enable or disable the checking of parameter properties.\nBecause parameter properties create properties on the class, it may be undesirable to force them to be readonly.\n\nExamples of code for this rule with `{checkParameterProperties: true}`:\n\n\u003c!--tabs--\u003e\n\n#### ❌ Incorrect\n\n```ts\nclass Foo {\n  constructor(private paramProp: string[]) {}\n}\n```\n\n#### ✅ Correct\n\n```ts\nclass Foo {\n  constructor(private paramProp: readonly string[]) {}\n}\n```\n\n\u003c!--/tabs--\u003e\n\nExamples of **correct** code for this rule with `{checkParameterProperties: false}`:\n\n```ts\nclass Foo {\n  constructor(\n    private paramProp1: string[],\n    private paramProp2: readonly string[],\n  ) {}\n}\n```\n\n### `ignoreInferredTypes`\n\nThis option allows you to ignore parameters which don't explicitly specify a type. This may be desirable in cases where an external dependency specifies a callback with mutable parameters, and manually annotating the callback's parameters is undesirable.\n\nExamples of code for this rule with `{ignoreInferredTypes: true}`:\n\n\u003c!--tabs--\u003e\n\n#### ❌ Incorrect\n\n```ts\nimport { acceptsCallback, CallbackOptions } from 'external-dependency';\n\nacceceptsCallback((options: CallbackOptions) =\u003e {});\n```\n\n\u003cdetails\u003e\n\u003csummary\u003eexternal-dependency.d.ts\u003c/summary\u003e\n\n```ts\nexport interface CallbackOptions {\n  prop: string;\n}\ntype Callback = (options: CallbackOptions) =\u003e void;\ntype AcceptsCallback = (callback: Callback) =\u003e void;\n\nexport const acceptsCallback: AcceptsCallback;\n```\n\n\u003c/details\u003e\n\n#### ✅ Correct\n\n```ts\nimport { acceptsCallback } from 'external-dependency';\n\nacceceptsCallback(options =\u003e {});\n```\n\n\u003cdetails\u003e\n\u003csummary\u003eexternal-dependency.d.ts\u003c/summary\u003e\n\n```ts\nexport interface CallbackOptions {\n  prop: string;\n}\ntype Callback = (options: CallbackOptions) =\u003e void;\ntype AcceptsCallback = (callback: Callback) =\u003e void;\n\nexport const acceptsCallback: AcceptsCallback;\n```\n\n\u003c/details\u003e\n\n### `treatMethodsAsReadonly`\n\nThis option allows you to treat all mutable methods as though they were readonly. This may be desirable in when you are never reassigning methods.\n\nExamples of code for this rule with `{treatMethodsAsReadonly: false}`:\n\n\u003c!--tabs--\u003e\n\n#### ❌ Incorrect\n\n```ts\ntype MyType = {\n  readonly prop: string;\n  method(): string; // note: this method is mutable\n};\nfunction foo(arg: MyType) {}\n```\n\n#### ✅ Correct\n\n```ts\ntype MyType = Readonly\u003c{\n  prop: string;\n  method(): string;\n}\u003e;\nfunction foo(arg: MyType) {}\n\ntype MyOtherType = {\n  readonly prop: string;\n  readonly method: () =\u003e string;\n};\nfunction bar(arg: MyOtherType) {}\n```\n\n\u003c!--/tabs--\u003e\n\nExamples of **correct** code for this rule with `{treatMethodsAsReadonly: true}`:\n\n```ts\ntype MyType = {\n  readonly prop: string;\n  method(): string; // note: this method is mutable\n};\nfunction foo(arg: MyType) {}\n```\n\n## Attributes\n\n- [ ] ✅ Recommended\n- [ ] 🔧 Fixable\n- [x] 💭 Requires type information\n"},"__N_SSG":true},"page":"/[rule]","query":{"rule":"prefer-readonly-parameter-types.md"},"buildId":"V190Mxkh11cN1_jT2mDz7","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>