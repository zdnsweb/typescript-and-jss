<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="minimum-scale=1, initial-scale=1, width=device-width"/><meta name="theme-color" content="#1976d2"/><title class="jsx-cbfd42e26539136">Typescript and JSS</title><link rel="icon" href="/zdns.svg" class="jsx-cbfd42e26539136"/><meta name="next-head-count" content="5"/><meta name="theme-color" content="#90caf9"/><link rel="preload" href="/_next/static/css/ef46db3751d8e999.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ef46db3751d8e999.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-fcec467324f41dbb.js" defer=""></script><script src="/_next/static/chunks/framework-e70c6273bfe3f237.js" defer=""></script><script src="/_next/static/chunks/main-7c9e8fd8226b6573.js" defer=""></script><script src="/_next/static/chunks/pages/_app-0617cd64ea924586.js" defer=""></script><script src="/_next/static/chunks/505-0c2bccf53cd8dae5.js" defer=""></script><script src="/_next/static/chunks/pages/%5Brule%5D-b74fec192cf33e56.js" defer=""></script><script src="/_next/static/V190Mxkh11cN1_jT2mDz7/_buildManifest.js" defer=""></script><script src="/_next/static/V190Mxkh11cN1_jT2mDz7/_ssgManifest.js" defer=""></script><script src="/_next/static/V190Mxkh11cN1_jT2mDz7/_middlewareManifest.js" defer=""></script><style id="__jsx-4ab09977da39fd03">.container.jsx-cbfd42e26539136{min-height:100vh;padding:0 .5rem;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}main.jsx-cbfd42e26539136{padding:5rem 0;-webkit-flex:1;-ms-flex:1;flex:1;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}footer.jsx-cbfd42e26539136{width:100%;height:100px;border-top:1px solid#eaeaea;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}footer.jsx-cbfd42e26539136 img.jsx-cbfd42e26539136{margin-left:.5rem}footer.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}a.jsx-cbfd42e26539136{color:inherit;text-decoration:none}.title.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136{color:#0070f3;text-decoration:none}.title.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136:hover,.title.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136:focus,.title.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136:active{text-decoration:underline}.title.jsx-cbfd42e26539136{margin:0;line-height:1.15;font-size:4rem}.title.jsx-cbfd42e26539136,.description.jsx-cbfd42e26539136{text-align:center}.description.jsx-cbfd42e26539136{line-height:1.5;font-size:1.5rem}code.jsx-cbfd42e26539136{background:#fafafa;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px;padding:.75rem;font-size:1.1rem;font-family:Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace}.grid.jsx-cbfd42e26539136{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-justify-content:center;justify-content:center;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;max-width:800px;margin-top:3rem}.card.jsx-cbfd42e26539136{margin:1rem;-webkit-flex-basis:45%;-ms-flex-preferred-size:45%;flex-basis:45%;padding:1.5rem;text-align:left;color:inherit;text-decoration:none;border:1px solid#eaeaea;-webkit-border-radius:10px;-moz-border-radius:10px;border-radius:10px;-webkit-transition:color.15s ease,border-color.15s ease;-moz-transition:color.15s ease,border-color.15s ease;-o-transition:color.15s ease,border-color.15s ease;transition:color.15s ease,border-color.15s ease}.card.jsx-cbfd42e26539136:hover,.card.jsx-cbfd42e26539136:focus,.card.jsx-cbfd42e26539136:active{color:#0070f3;border-color:#0070f3}.card.jsx-cbfd42e26539136 h3.jsx-cbfd42e26539136{margin:0 0 1rem 0;font-size:1.5rem}.card.jsx-cbfd42e26539136 p.jsx-cbfd42e26539136{margin:0;font-size:1.25rem;line-height:1.5}.logo.jsx-cbfd42e26539136{height:1em}@media(max-width:600px){.grid.jsx-cbfd42e26539136{width:100%;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}}</style><style id="__jsx-5750d7069672f50d">html,body{padding:0;margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif}*{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}</style><style data-emotion="css "></style></head><body><div id="__next" data-reactroot=""><style data-emotion="css-global o6gwfi">html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;box-sizing:border-box;-webkit-text-size-adjust:100%;}*,*::before,*::after{box-sizing:inherit;}strong,b{font-weight:700;}body{margin:0;color:rgba(0, 0, 0, 0.87);font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;background-color:#fff;}@media print{body{background-color:#fff;}}body::backdrop{background-color:#fff;}</style><div class="jsx-cbfd42e26539136 container"><main class="jsx-cbfd42e26539136"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation1 css-aoeo82"><h1><code>member-delimiter-style</code></h1>
<p>Require a specific member delimiter style for interfaces and type literals.</p>
<p>Enforces a consistent member delimiter style in interfaces and type literals. There are three member delimiter styles primarily used in TypeScript:</p>
<ul>
<li>Semicolon style (default, preferred in TypeScript).</li>
</ul>
<!-- -->&lt;!-- prettier-ignore --&gt;<!-- -->
<pre><code class="language-ts">interface Foo {
    name: string;
    greet(): void;
}

type Bar = {
    name: string;
    greet(): void;
}
</code></pre>
<ul>
<li>Comma style (JSON style).</li>
</ul>
<!-- -->&lt;!-- prettier-ignore --&gt;<!-- -->
<pre><code class="language-ts">interface Foo {
    name: string,
    greet(): void,
}

type Bar = {
    name: string,
    greet(): void,
}
</code></pre>
<ul>
<li>Line break (none) style.</li>
</ul>
<!-- -->&lt;!-- prettier-ignore --&gt;<!-- -->
<pre><code class="language-ts">interface Foo {
    name: string
    greet(): void
}

type Bar = {
    name: string
    greet(): void
}
</code></pre>
<p>The rule also enforces the presence (or absence) of the delimiter in the last member of the interface and/or type literal.
Finally, this rule can enforce separate delimiter syntax for single line declarations.</p>
<h2>Rule Details</h2>
<p>This rule aims to standardize the way interface and type literal members are delimited.</p>
<h2>Options</h2>
<pre><code class="language-ts">interface BaseConfig {
  multiline?: {
    delimiter?: &#x27;none&#x27; | &#x27;semi&#x27; | &#x27;comma&#x27;;
    requireLast?: boolean;
  };
  singleline?: {
    delimiter?: &#x27;semi&#x27; | &#x27;comma&#x27;;
    requireLast?: boolean;
  };
}
type Config = BaseConfig &amp; {
  overrides?: {
    interface?: BaseConfig;
    typeLiteral?: BaseConfig;
  };
  multilineDetection?: &#x27;brackets&#x27; | &#x27;last-member&#x27;;
};
</code></pre>
<p>Default config:</p>
<pre><code class="language-json">{
  &quot;multiline&quot;: {
    &quot;delimiter&quot;: &quot;semi&quot;,
    &quot;requireLast&quot;: true
  },
  &quot;singleline&quot;: {
    &quot;delimiter&quot;: &quot;semi&quot;,
    &quot;requireLast&quot;: false
  },
  &quot;multilineDetection&quot;: &quot;brackets&quot;
}
</code></pre>
<p><code>multiline</code> config only applies to multiline <code>interface</code>/<code>type</code> definitions.
<code>singleline</code> config only applies to single line <code>interface</code>/<code>type</code> definitions.
The two configs are entirely separate, and do not effect one another.</p>
<p><code>multilineDetection</code> determines what counts as multiline</p>
<ul>
<li><code>&quot;brackets&quot;</code> (default) any newlines in the type or interface make it multiline.</li>
<li><code>&quot;last-member&quot;</code> if the last member of the interface is on the same line as the last bracket, it is counted as a single line.</li>
</ul>
<h3><code>delimiter</code></h3>
<p>Accepts three values (or two for <code>singleline</code>):</p>
<ul>
<li><code>comma</code> - each member should be delimited with a comma (<code>,</code>).</li>
<li><code>semi</code> - each member should be delimited with a semicolon (<code>;</code>).</li>
<li><code>none</code> - each member should be delimited with nothing.</li>
</ul>
<p>:::note
<code>none</code> is not an option for <code>singleline</code> because having no delimiter between members on a single line is a syntax error in TS.
:::</p>
<h3><code>requireLast</code></h3>
<p>Determines whether or not the last member in the <code>interface</code>/<code>type</code> should have a delimiter:</p>
<ul>
<li><code>true</code> - the last member <strong><em>must</em></strong> have a delimiter.</li>
<li><code>false</code> - the last member <strong><em>must not</em></strong> have a delimiter.</li>
</ul>
<h3><code>overrides</code></h3>
<p>Allows you to specify options specifically for either <code>interface</code>s or <code>type</code> definitions / inline <code>type</code>s.</p>
<p>For example, to require commas for <code>type</code>s, and semicolons for multiline <code>interface</code>s:</p>
<pre><code class="language-json">{
  &quot;multiline&quot;: {
    &quot;delimiter&quot;: &quot;comma&quot;,
    &quot;requireLast&quot;: true
  },
  &quot;singleline&quot;: {
    &quot;delimiter&quot;: &quot;comma&quot;,
    &quot;requireLast&quot;: true
  },
  &quot;overrides&quot;: {
    &quot;interface&quot;: {
      &quot;multiline&quot;: {
        &quot;delimiter&quot;: &quot;semi&quot;,
        &quot;requireLast&quot;: true
      }
    }
  }
}
</code></pre>
<h2>Examples</h2>
<p>Examples of code for this rule with the default config:</p>
<!-- -->&lt;!--tabs--&gt;<!-- -->
<h3>❌ Incorrect</h3>
<!-- -->&lt;!-- prettier-ignore --&gt;<!-- -->
<pre><code class="language-ts">// missing semicolon delimiter
interface Foo {
    name: string
    greet(): string
}

// using incorrect delimiter
interface Bar {
    name: string,
    greet(): string,
}

// missing last member delimiter
interface Baz {
    name: string;
    greet(): string
}

// incorrect delimiter
type FooBar = { name: string, greet(): string }

// last member should not have delimiter
type FooBar = { name: string; greet(): string; }
</code></pre>
<h3>✅ Correct</h3>
<!-- -->&lt;!-- prettier-ignore --&gt;<!-- -->
<pre><code class="language-ts">interface Foo {
    name: string;
    greet(): string;
}

interface Foo { name: string }

type Bar = {
    name: string;
    greet(): string;
}

type Bar = { name: string }

type FooBar = { name: string; greet(): string }
</code></pre>
<h2>When Not To Use It</h2>
<p>If you don&#x27;t care about enforcing a consistent member delimiter in interfaces and type literals, then you will not need this rule.</p>
<h2>Attributes</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled=""/> <!-- -->✅ Recommended</li>
<li class="task-list-item"><input type="checkbox" checked="" disabled=""/> <!-- -->🔧 Fixable</li>
<li class="task-list-item"><input type="checkbox" disabled=""/> <!-- -->💭 Requires type information</li>
</ul></div></main><footer class="jsx-cbfd42e26539136"><a href="https://cloud.zdns.cn" target="_blank" rel="noopener noreferrer" class="jsx-cbfd42e26539136">Powered by <img src="/zdns.svg" alt="zdns" class="jsx-cbfd42e26539136 logo"/></a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"rule":"# `member-delimiter-style`\n\nRequire a specific member delimiter style for interfaces and type literals.\n\nEnforces a consistent member delimiter style in interfaces and type literals. There are three member delimiter styles primarily used in TypeScript:\n\n- Semicolon style (default, preferred in TypeScript).\n\n\u003c!-- prettier-ignore --\u003e\n```ts\ninterface Foo {\n    name: string;\n    greet(): void;\n}\n\ntype Bar = {\n    name: string;\n    greet(): void;\n}\n```\n\n- Comma style (JSON style).\n\n\u003c!-- prettier-ignore --\u003e\n```ts\ninterface Foo {\n    name: string,\n    greet(): void,\n}\n\ntype Bar = {\n    name: string,\n    greet(): void,\n}\n```\n\n- Line break (none) style.\n\n\u003c!-- prettier-ignore --\u003e\n```ts\ninterface Foo {\n    name: string\n    greet(): void\n}\n\ntype Bar = {\n    name: string\n    greet(): void\n}\n```\n\nThe rule also enforces the presence (or absence) of the delimiter in the last member of the interface and/or type literal.\nFinally, this rule can enforce separate delimiter syntax for single line declarations.\n\n## Rule Details\n\nThis rule aims to standardize the way interface and type literal members are delimited.\n\n## Options\n\n```ts\ninterface BaseConfig {\n  multiline?: {\n    delimiter?: 'none' | 'semi' | 'comma';\n    requireLast?: boolean;\n  };\n  singleline?: {\n    delimiter?: 'semi' | 'comma';\n    requireLast?: boolean;\n  };\n}\ntype Config = BaseConfig \u0026 {\n  overrides?: {\n    interface?: BaseConfig;\n    typeLiteral?: BaseConfig;\n  };\n  multilineDetection?: 'brackets' | 'last-member';\n};\n```\n\nDefault config:\n\n```json\n{\n  \"multiline\": {\n    \"delimiter\": \"semi\",\n    \"requireLast\": true\n  },\n  \"singleline\": {\n    \"delimiter\": \"semi\",\n    \"requireLast\": false\n  },\n  \"multilineDetection\": \"brackets\"\n}\n```\n\n`multiline` config only applies to multiline `interface`/`type` definitions.\n`singleline` config only applies to single line `interface`/`type` definitions.\nThe two configs are entirely separate, and do not effect one another.\n\n`multilineDetection` determines what counts as multiline\n\n- `\"brackets\"` (default) any newlines in the type or interface make it multiline.\n- `\"last-member\"` if the last member of the interface is on the same line as the last bracket, it is counted as a single line.\n\n### `delimiter`\n\nAccepts three values (or two for `singleline`):\n\n- `comma` - each member should be delimited with a comma (`,`).\n- `semi` - each member should be delimited with a semicolon (`;`).\n- `none` - each member should be delimited with nothing.\n\n:::note\n`none` is not an option for `singleline` because having no delimiter between members on a single line is a syntax error in TS.\n:::\n\n### `requireLast`\n\nDetermines whether or not the last member in the `interface`/`type` should have a delimiter:\n\n- `true` - the last member **_must_** have a delimiter.\n- `false` - the last member **_must not_** have a delimiter.\n\n### `overrides`\n\nAllows you to specify options specifically for either `interface`s or `type` definitions / inline `type`s.\n\nFor example, to require commas for `type`s, and semicolons for multiline `interface`s:\n\n```json\n{\n  \"multiline\": {\n    \"delimiter\": \"comma\",\n    \"requireLast\": true\n  },\n  \"singleline\": {\n    \"delimiter\": \"comma\",\n    \"requireLast\": true\n  },\n  \"overrides\": {\n    \"interface\": {\n      \"multiline\": {\n        \"delimiter\": \"semi\",\n        \"requireLast\": true\n      }\n    }\n  }\n}\n```\n\n## Examples\n\nExamples of code for this rule with the default config:\n\n\u003c!--tabs--\u003e\n\n### ❌ Incorrect\n\n\u003c!-- prettier-ignore --\u003e\n```ts\n// missing semicolon delimiter\ninterface Foo {\n    name: string\n    greet(): string\n}\n\n// using incorrect delimiter\ninterface Bar {\n    name: string,\n    greet(): string,\n}\n\n// missing last member delimiter\ninterface Baz {\n    name: string;\n    greet(): string\n}\n\n// incorrect delimiter\ntype FooBar = { name: string, greet(): string }\n\n// last member should not have delimiter\ntype FooBar = { name: string; greet(): string; }\n```\n\n### ✅ Correct\n\n\u003c!-- prettier-ignore --\u003e\n```ts\ninterface Foo {\n    name: string;\n    greet(): string;\n}\n\ninterface Foo { name: string }\n\ntype Bar = {\n    name: string;\n    greet(): string;\n}\n\ntype Bar = { name: string }\n\ntype FooBar = { name: string; greet(): string }\n```\n\n## When Not To Use It\n\nIf you don't care about enforcing a consistent member delimiter in interfaces and type literals, then you will not need this rule.\n\n## Attributes\n\n- [ ] ✅ Recommended\n- [x] 🔧 Fixable\n- [ ] 💭 Requires type information\n"},"__N_SSG":true},"page":"/[rule]","query":{"rule":"member-delimiter-style.md"},"buildId":"V190Mxkh11cN1_jT2mDz7","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>