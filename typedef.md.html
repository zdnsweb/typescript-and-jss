<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="minimum-scale=1, initial-scale=1, width=device-width"/><meta name="theme-color" content="#1976d2"/><title class="jsx-cbfd42e26539136">Typescript and JSS</title><link rel="icon" href="/zdns.svg" class="jsx-cbfd42e26539136"/><meta name="next-head-count" content="5"/><meta name="theme-color" content="#90caf9"/><link rel="preload" href="/_next/static/css/ef46db3751d8e999.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ef46db3751d8e999.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-fcec467324f41dbb.js" defer=""></script><script src="/_next/static/chunks/framework-e70c6273bfe3f237.js" defer=""></script><script src="/_next/static/chunks/main-7c9e8fd8226b6573.js" defer=""></script><script src="/_next/static/chunks/pages/_app-0617cd64ea924586.js" defer=""></script><script src="/_next/static/chunks/505-0c2bccf53cd8dae5.js" defer=""></script><script src="/_next/static/chunks/pages/%5Brule%5D-b74fec192cf33e56.js" defer=""></script><script src="/_next/static/V190Mxkh11cN1_jT2mDz7/_buildManifest.js" defer=""></script><script src="/_next/static/V190Mxkh11cN1_jT2mDz7/_ssgManifest.js" defer=""></script><script src="/_next/static/V190Mxkh11cN1_jT2mDz7/_middlewareManifest.js" defer=""></script><style id="__jsx-4ab09977da39fd03">.container.jsx-cbfd42e26539136{min-height:100vh;padding:0 .5rem;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}main.jsx-cbfd42e26539136{padding:5rem 0;-webkit-flex:1;-ms-flex:1;flex:1;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}footer.jsx-cbfd42e26539136{width:100%;height:100px;border-top:1px solid#eaeaea;display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}footer.jsx-cbfd42e26539136 img.jsx-cbfd42e26539136{margin-left:.5rem}footer.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-justify-content:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}a.jsx-cbfd42e26539136{color:inherit;text-decoration:none}.title.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136{color:#0070f3;text-decoration:none}.title.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136:hover,.title.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136:focus,.title.jsx-cbfd42e26539136 a.jsx-cbfd42e26539136:active{text-decoration:underline}.title.jsx-cbfd42e26539136{margin:0;line-height:1.15;font-size:4rem}.title.jsx-cbfd42e26539136,.description.jsx-cbfd42e26539136{text-align:center}.description.jsx-cbfd42e26539136{line-height:1.5;font-size:1.5rem}code.jsx-cbfd42e26539136{background:#fafafa;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px;padding:.75rem;font-size:1.1rem;font-family:Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace}.grid.jsx-cbfd42e26539136{display:-webkit-box;display:-webkit-flex;display:-moz-box;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-justify-content:center;justify-content:center;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;max-width:800px;margin-top:3rem}.card.jsx-cbfd42e26539136{margin:1rem;-webkit-flex-basis:45%;-ms-flex-preferred-size:45%;flex-basis:45%;padding:1.5rem;text-align:left;color:inherit;text-decoration:none;border:1px solid#eaeaea;-webkit-border-radius:10px;-moz-border-radius:10px;border-radius:10px;-webkit-transition:color.15s ease,border-color.15s ease;-moz-transition:color.15s ease,border-color.15s ease;-o-transition:color.15s ease,border-color.15s ease;transition:color.15s ease,border-color.15s ease}.card.jsx-cbfd42e26539136:hover,.card.jsx-cbfd42e26539136:focus,.card.jsx-cbfd42e26539136:active{color:#0070f3;border-color:#0070f3}.card.jsx-cbfd42e26539136 h3.jsx-cbfd42e26539136{margin:0 0 1rem 0;font-size:1.5rem}.card.jsx-cbfd42e26539136 p.jsx-cbfd42e26539136{margin:0;font-size:1.25rem;line-height:1.5}.logo.jsx-cbfd42e26539136{height:1em}@media(max-width:600px){.grid.jsx-cbfd42e26539136{width:100%;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}}</style><style id="__jsx-5750d7069672f50d">html,body{padding:0;margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif}*{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}</style><style data-emotion="css "></style></head><body><div id="__next" data-reactroot=""><style data-emotion="css-global o6gwfi">html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;box-sizing:border-box;-webkit-text-size-adjust:100%;}*,*::before,*::after{box-sizing:inherit;}strong,b{font-weight:700;}body{margin:0;color:rgba(0, 0, 0, 0.87);font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;background-color:#fff;}@media print{body{background-color:#fff;}}body::backdrop{background-color:#fff;}</style><div class="jsx-cbfd42e26539136 container"><main class="jsx-cbfd42e26539136"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation1 css-aoeo82"><h1><code>typedef</code></h1>
<p>Requires type annotations to exist.</p>
<p>TypeScript cannot always infer types for all places in code.
Some locations require type annotations for their types to be inferred.</p>
<pre><code class="language-ts">class ContainsText {
  // There must be a type annotation here to infer the type
  delayedText: string;

  // `typedef` requires a type annotation here to maintain consistency
  immediateTextExplicit: string = &#x27;text&#x27;;

  // This is still a string type because of its initial value
  immediateTextImplicit = &#x27;text&#x27;;
}
</code></pre>
<p><strong><em>Note:</em></strong> requiring type annotations unnecessarily can be cumbersome to maintain and generally reduces code readability.
TypeScript is often better at inferring types than easily written type annotations would allow.</p>
<p><strong>Instead of enabling <code>typedef</code>, it is generally recommended to use the <code>--noImplicitAny</code> and <code>--strictPropertyInitialization</code> compiler options to enforce type annotations only when useful.</strong></p>
<h2>Rule Details</h2>
<p>This rule can enforce type annotations in locations regardless of whether they&#x27;re required.
This is typically used to maintain consistency for element types that sometimes require them.</p>
<blockquote>
<p>To enforce type definitions existing on call signatures as per TSLint&#x27;s <code>arrow-call-signature</code> and <code>call-signature</code> options, use <code>explicit-function-return-type</code>, or <code>explicit-module-boundary-types</code>.</p>
</blockquote>
<h2>Options</h2>
<pre><code class="language-ts">type Options = {
  arrayDestructuring?: boolean;
  arrowParameter?: boolean;
  memberVariableDeclaration?: boolean;
  objectDestructuring?: boolean;
  parameter?: boolean;
  propertyDeclaration?: boolean;
  variableDeclaration?: boolean;
  variableDeclarationIgnoreFunction?: boolean;
};

const defaultOptions: Options = {
  arrayDestructuring: false,
  arrowParameter: false,
  memberVariableDeclaration: false,
  objectDestructuring: false,
  parameter: false,
  propertyDeclaration: false,
  variableDeclaration: false,
  variableDeclarationIgnoreFunction: false,
};
</code></pre>
<p>For example, with the following configuration:</p>
<pre><code class="language-json">{
  &quot;rules&quot;: {
    &quot;@typescript-eslint/typedef&quot;: [
      &quot;error&quot;,
      {
        &quot;arrowParameter&quot;: true,
        &quot;variableDeclaration&quot;: true
      }
    ]
  }
}
</code></pre>
<ul>
<li>Type annotations on arrow function parameters are required</li>
<li>Type annotations on variables are required</li>
</ul>
<h3><code>arrayDestructuring</code></h3>
<p>Whether to enforce type annotations on variables declared using array destructuring.</p>
<p>Examples of code with <code>{ &quot;arrayDestructuring&quot;: true }</code>:</p>
<!-- -->&lt;!--tabs--&gt;<!-- -->
<h4>❌ Incorrect</h4>
<pre><code class="language-ts">const [a] = [1];
const [b, c] = [1, 2];
</code></pre>
<h4>✅ Correct</h4>
<pre><code class="language-ts">const [a]: number[] = [1];
const [b]: [number] = [2];
const [c, d]: [boolean, string] = [true, &#x27;text&#x27;];

for (const [key, val] of new Map([[&#x27;key&#x27;, 1]])) {
}
</code></pre>
<h3><code>arrowParameter</code></h3>
<p>Whether to enforce type annotations for parameters of arrow functions.</p>
<p>Examples of code with <code>{ &quot;arrowParameter&quot;: true }</code>:</p>
<!-- -->&lt;!--tabs--&gt;<!-- -->
<h4>❌ Incorrect</h4>
<pre><code class="language-ts">const logsSize = size =&gt; console.log(size);

[&#x27;hello&#x27;, &#x27;world&#x27;].map(text =&gt; text.length);

const mapper = {
  map: text =&gt; text + &#x27;...&#x27;,
};
</code></pre>
<h4>✅ Correct</h4>
<pre><code class="language-ts">const logsSize = (size: number) =&gt; console.log(size);

[&#x27;hello&#x27;, &#x27;world&#x27;].map((text: string) =&gt; text.length);

const mapper = {
  map: (text: string) =&gt; text + &#x27;...&#x27;,
};
</code></pre>
<h3><code>memberVariableDeclaration</code></h3>
<p>Whether to enforce type annotations on member variables of classes.</p>
<p>Examples of code with <code>{ &quot;memberVariableDeclaration&quot;: true }</code>:</p>
<!-- -->&lt;!--tabs--&gt;<!-- -->
<h4>❌ Incorrect</h4>
<pre><code class="language-ts">class ContainsText {
  delayedText;
  immediateTextImplicit = &#x27;text&#x27;;
}
</code></pre>
<h4>✅ Correct</h4>
<pre><code class="language-ts">class ContainsText {
  delayedText: string;
  immediateTextImplicit: string = &#x27;text&#x27;;
}
</code></pre>
<h3><code>objectDestructuring</code></h3>
<p>Whether to enforce type annotations on variables declared using object destructuring.</p>
<p>Examples of code with <code>{ &quot;objectDestructuring&quot;: true }</code>:</p>
<!-- -->&lt;!--tabs--&gt;<!-- -->
<h4>❌ Incorrect</h4>
<pre><code class="language-ts">const { length } = &#x27;text&#x27;;
const [b, c] = Math.random() ? [1, 2] : [3, 4];
</code></pre>
<h4>✅ Correct</h4>
<pre><code class="language-ts">const { length }: { length: number } = &#x27;text&#x27;;
const [b, c]: [number, number] = Math.random() ? [1, 2] : [3, 4];

for (const { key, val } of [{ key: &#x27;key&#x27;, val: 1 }]) {
}
</code></pre>
<h3><code>parameter</code></h3>
<p>Whether to enforce type annotations for parameters of functions and methods.</p>
<p>Examples of code with <code>{ &quot;parameter&quot;: true }</code>:</p>
<!-- -->&lt;!--tabs--&gt;<!-- -->
<h4>❌ Incorrect</h4>
<pre><code class="language-ts">function logsSize(size): void {
  console.log(size);
}

const doublesSize = function (size): number {
  return size * 2;
};

const divider = {
  curriesSize(size): number {
    return size;
  },
  dividesSize: function (size): number {
    return size / 2;
  },
};

class Logger {
  log(text): boolean {
    console.log(&#x27;&gt;&#x27;, text);
    return true;
  }
}
</code></pre>
<h4>✅ Correct</h4>
<pre><code class="language-ts">function logsSize(size: number): void {
  console.log(size);
}

const doublesSize = function (size: number): number {
  return size * 2;
};

const divider = {
  curriesSize(size: number): number {
    return size;
  },
  dividesSize: function (size: number): number {
    return size / 2;
  },
};

class Logger {
  log(text: boolean): boolean {
    console.log(&#x27;&gt;&#x27;, text);
    return true;
  }
}
</code></pre>
<h3><code>propertyDeclaration</code></h3>
<p>Whether to enforce type annotations for properties of interfaces and types.</p>
<p>Examples of code with <code>{ &quot;propertyDeclaration&quot;: true }</code>:</p>
<!-- -->&lt;!--tabs--&gt;<!-- -->
<h4>❌ Incorrect</h4>
<pre><code class="language-ts">type Members = {
  member;
  otherMember;
};
</code></pre>
<h4>✅ Correct</h4>
<pre><code class="language-ts">type Members = {
  member: boolean;
  otherMember: string;
};
</code></pre>
<h3><code>variableDeclaration</code></h3>
<p>Whether to enforce type annotations for variable declarations, excluding array and object destructuring.</p>
<p>Examples of code with <code>{ &quot;variableDeclaration&quot;: true }</code>:</p>
<!-- -->&lt;!--tabs--&gt;<!-- -->
<h4>❌ Incorrect</h4>
<pre><code class="language-ts">const text = &#x27;text&#x27;;
let initialText = &#x27;text&#x27;;
let delayedText;
</code></pre>
<h4>✅ Correct</h4>
<pre><code class="language-ts">const text: string = &#x27;text&#x27;;
let initialText: string = &#x27;text&#x27;;
let delayedText: string;
</code></pre>
<h3><code>variableDeclarationIgnoreFunction</code></h3>
<p>Ignore variable declarations for non-arrow and arrow functions.</p>
<p>Examples of code with <code>{ &quot;variableDeclaration&quot;: true, &quot;variableDeclarationIgnoreFunction&quot;: true }</code>:</p>
<!-- -->&lt;!--tabs--&gt;<!-- -->
<h4>❌ Incorrect</h4>
<pre><code class="language-ts">const text = &#x27;text&#x27;;
</code></pre>
<h4>✅ Correct</h4>
<pre><code class="language-ts">const a = (): void =&gt; {};
const b = function (): void =&gt; {};
const c: () =&gt; void = (): void =&gt; {};

class Foo {
  a = (): void =&gt; {};
  b = function (): void =&gt; {};
  c = () =&gt; void = (): void =&gt; {};
}
</code></pre>
<h2>When Not To Use It</h2>
<p>If you are using stricter TypeScript compiler options, particularly <code>--noImplicitAny</code> and/or <code>--strictPropertyInitialization</code>, you likely don&#x27;t need this rule.</p>
<p>In general, if you do not consider the cost of writing unnecessary type annotations reasonable, then do not use this rule.</p>
<h2>Further Reading</h2>
<ul>
<li><a href="https://basarat.gitbooks.io/typescript/docs/types/type-system.html">TypeScript Type System</a></li>
<li><a href="https://www.typescriptlang.org/docs/handbook/type-inference.html">Type Inference</a></li>
</ul>
<h2>Related To</h2>
<ul>
<li>TSLint: <a href="https://palantir.github.io/tslint/rules/typedef"><code>typedef</code></a></li>
</ul>
<h2>Attributes</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled=""/> <!-- -->✅ Recommended</li>
<li class="task-list-item"><input type="checkbox" disabled=""/> <!-- -->🔧 Fixable</li>
<li class="task-list-item"><input type="checkbox" disabled=""/> <!-- -->💭 Requires type information</li>
</ul></div></main><footer class="jsx-cbfd42e26539136"><a href="https://cloud.zdns.cn" target="_blank" rel="noopener noreferrer" class="jsx-cbfd42e26539136">Powered by <img src="/zdns.svg" alt="zdns" class="jsx-cbfd42e26539136 logo"/></a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"rule":"# `typedef`\n\nRequires type annotations to exist.\n\nTypeScript cannot always infer types for all places in code.\nSome locations require type annotations for their types to be inferred.\n\n```ts\nclass ContainsText {\n  // There must be a type annotation here to infer the type\n  delayedText: string;\n\n  // `typedef` requires a type annotation here to maintain consistency\n  immediateTextExplicit: string = 'text';\n\n  // This is still a string type because of its initial value\n  immediateTextImplicit = 'text';\n}\n```\n\n**_Note:_** requiring type annotations unnecessarily can be cumbersome to maintain and generally reduces code readability.\nTypeScript is often better at inferring types than easily written type annotations would allow.\n\n**Instead of enabling `typedef`, it is generally recommended to use the `--noImplicitAny` and `--strictPropertyInitialization` compiler options to enforce type annotations only when useful.**\n\n## Rule Details\n\nThis rule can enforce type annotations in locations regardless of whether they're required.\nThis is typically used to maintain consistency for element types that sometimes require them.\n\n\u003e To enforce type definitions existing on call signatures as per TSLint's `arrow-call-signature` and `call-signature` options, use `explicit-function-return-type`, or `explicit-module-boundary-types`.\n\n## Options\n\n```ts\ntype Options = {\n  arrayDestructuring?: boolean;\n  arrowParameter?: boolean;\n  memberVariableDeclaration?: boolean;\n  objectDestructuring?: boolean;\n  parameter?: boolean;\n  propertyDeclaration?: boolean;\n  variableDeclaration?: boolean;\n  variableDeclarationIgnoreFunction?: boolean;\n};\n\nconst defaultOptions: Options = {\n  arrayDestructuring: false,\n  arrowParameter: false,\n  memberVariableDeclaration: false,\n  objectDestructuring: false,\n  parameter: false,\n  propertyDeclaration: false,\n  variableDeclaration: false,\n  variableDeclarationIgnoreFunction: false,\n};\n```\n\nFor example, with the following configuration:\n\n```json\n{\n  \"rules\": {\n    \"@typescript-eslint/typedef\": [\n      \"error\",\n      {\n        \"arrowParameter\": true,\n        \"variableDeclaration\": true\n      }\n    ]\n  }\n}\n```\n\n- Type annotations on arrow function parameters are required\n- Type annotations on variables are required\n\n### `arrayDestructuring`\n\nWhether to enforce type annotations on variables declared using array destructuring.\n\nExamples of code with `{ \"arrayDestructuring\": true }`:\n\n\u003c!--tabs--\u003e\n\n#### ❌ Incorrect\n\n```ts\nconst [a] = [1];\nconst [b, c] = [1, 2];\n```\n\n#### ✅ Correct\n\n```ts\nconst [a]: number[] = [1];\nconst [b]: [number] = [2];\nconst [c, d]: [boolean, string] = [true, 'text'];\n\nfor (const [key, val] of new Map([['key', 1]])) {\n}\n```\n\n### `arrowParameter`\n\nWhether to enforce type annotations for parameters of arrow functions.\n\nExamples of code with `{ \"arrowParameter\": true }`:\n\n\u003c!--tabs--\u003e\n\n#### ❌ Incorrect\n\n```ts\nconst logsSize = size =\u003e console.log(size);\n\n['hello', 'world'].map(text =\u003e text.length);\n\nconst mapper = {\n  map: text =\u003e text + '...',\n};\n```\n\n#### ✅ Correct\n\n```ts\nconst logsSize = (size: number) =\u003e console.log(size);\n\n['hello', 'world'].map((text: string) =\u003e text.length);\n\nconst mapper = {\n  map: (text: string) =\u003e text + '...',\n};\n```\n\n### `memberVariableDeclaration`\n\nWhether to enforce type annotations on member variables of classes.\n\nExamples of code with `{ \"memberVariableDeclaration\": true }`:\n\n\u003c!--tabs--\u003e\n\n#### ❌ Incorrect\n\n```ts\nclass ContainsText {\n  delayedText;\n  immediateTextImplicit = 'text';\n}\n```\n\n#### ✅ Correct\n\n```ts\nclass ContainsText {\n  delayedText: string;\n  immediateTextImplicit: string = 'text';\n}\n```\n\n### `objectDestructuring`\n\nWhether to enforce type annotations on variables declared using object destructuring.\n\nExamples of code with `{ \"objectDestructuring\": true }`:\n\n\u003c!--tabs--\u003e\n\n#### ❌ Incorrect\n\n```ts\nconst { length } = 'text';\nconst [b, c] = Math.random() ? [1, 2] : [3, 4];\n```\n\n#### ✅ Correct\n\n```ts\nconst { length }: { length: number } = 'text';\nconst [b, c]: [number, number] = Math.random() ? [1, 2] : [3, 4];\n\nfor (const { key, val } of [{ key: 'key', val: 1 }]) {\n}\n```\n\n### `parameter`\n\nWhether to enforce type annotations for parameters of functions and methods.\n\nExamples of code with `{ \"parameter\": true }`:\n\n\u003c!--tabs--\u003e\n\n#### ❌ Incorrect\n\n```ts\nfunction logsSize(size): void {\n  console.log(size);\n}\n\nconst doublesSize = function (size): number {\n  return size * 2;\n};\n\nconst divider = {\n  curriesSize(size): number {\n    return size;\n  },\n  dividesSize: function (size): number {\n    return size / 2;\n  },\n};\n\nclass Logger {\n  log(text): boolean {\n    console.log('\u003e', text);\n    return true;\n  }\n}\n```\n\n#### ✅ Correct\n\n```ts\nfunction logsSize(size: number): void {\n  console.log(size);\n}\n\nconst doublesSize = function (size: number): number {\n  return size * 2;\n};\n\nconst divider = {\n  curriesSize(size: number): number {\n    return size;\n  },\n  dividesSize: function (size: number): number {\n    return size / 2;\n  },\n};\n\nclass Logger {\n  log(text: boolean): boolean {\n    console.log('\u003e', text);\n    return true;\n  }\n}\n```\n\n### `propertyDeclaration`\n\nWhether to enforce type annotations for properties of interfaces and types.\n\nExamples of code with `{ \"propertyDeclaration\": true }`:\n\n\u003c!--tabs--\u003e\n\n#### ❌ Incorrect\n\n```ts\ntype Members = {\n  member;\n  otherMember;\n};\n```\n\n#### ✅ Correct\n\n```ts\ntype Members = {\n  member: boolean;\n  otherMember: string;\n};\n```\n\n### `variableDeclaration`\n\nWhether to enforce type annotations for variable declarations, excluding array and object destructuring.\n\nExamples of code with `{ \"variableDeclaration\": true }`:\n\n\u003c!--tabs--\u003e\n\n#### ❌ Incorrect\n\n```ts\nconst text = 'text';\nlet initialText = 'text';\nlet delayedText;\n```\n\n#### ✅ Correct\n\n```ts\nconst text: string = 'text';\nlet initialText: string = 'text';\nlet delayedText: string;\n```\n\n### `variableDeclarationIgnoreFunction`\n\nIgnore variable declarations for non-arrow and arrow functions.\n\nExamples of code with `{ \"variableDeclaration\": true, \"variableDeclarationIgnoreFunction\": true }`:\n\n\u003c!--tabs--\u003e\n\n#### ❌ Incorrect\n\n```ts\nconst text = 'text';\n```\n\n#### ✅ Correct\n\n```ts\nconst a = (): void =\u003e {};\nconst b = function (): void =\u003e {};\nconst c: () =\u003e void = (): void =\u003e {};\n\nclass Foo {\n  a = (): void =\u003e {};\n  b = function (): void =\u003e {};\n  c = () =\u003e void = (): void =\u003e {};\n}\n```\n\n## When Not To Use It\n\nIf you are using stricter TypeScript compiler options, particularly `--noImplicitAny` and/or `--strictPropertyInitialization`, you likely don't need this rule.\n\nIn general, if you do not consider the cost of writing unnecessary type annotations reasonable, then do not use this rule.\n\n## Further Reading\n\n- [TypeScript Type System](https://basarat.gitbooks.io/typescript/docs/types/type-system.html)\n- [Type Inference](https://www.typescriptlang.org/docs/handbook/type-inference.html)\n\n## Related To\n\n- TSLint: [`typedef`](https://palantir.github.io/tslint/rules/typedef)\n\n## Attributes\n\n- [ ] ✅ Recommended\n- [ ] 🔧 Fixable\n- [ ] 💭 Requires type information\n"},"__N_SSG":true},"page":"/[rule]","query":{"rule":"typedef.md"},"buildId":"V190Mxkh11cN1_jT2mDz7","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>