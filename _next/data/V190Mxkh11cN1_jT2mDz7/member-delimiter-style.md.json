{"pageProps":{"rule":"# `member-delimiter-style`\n\nRequire a specific member delimiter style for interfaces and type literals.\n\nEnforces a consistent member delimiter style in interfaces and type literals. There are three member delimiter styles primarily used in TypeScript:\n\n- Semicolon style (default, preferred in TypeScript).\n\n<!-- prettier-ignore -->\n```ts\ninterface Foo {\n    name: string;\n    greet(): void;\n}\n\ntype Bar = {\n    name: string;\n    greet(): void;\n}\n```\n\n- Comma style (JSON style).\n\n<!-- prettier-ignore -->\n```ts\ninterface Foo {\n    name: string,\n    greet(): void,\n}\n\ntype Bar = {\n    name: string,\n    greet(): void,\n}\n```\n\n- Line break (none) style.\n\n<!-- prettier-ignore -->\n```ts\ninterface Foo {\n    name: string\n    greet(): void\n}\n\ntype Bar = {\n    name: string\n    greet(): void\n}\n```\n\nThe rule also enforces the presence (or absence) of the delimiter in the last member of the interface and/or type literal.\nFinally, this rule can enforce separate delimiter syntax for single line declarations.\n\n## Rule Details\n\nThis rule aims to standardize the way interface and type literal members are delimited.\n\n## Options\n\n```ts\ninterface BaseConfig {\n  multiline?: {\n    delimiter?: 'none' | 'semi' | 'comma';\n    requireLast?: boolean;\n  };\n  singleline?: {\n    delimiter?: 'semi' | 'comma';\n    requireLast?: boolean;\n  };\n}\ntype Config = BaseConfig & {\n  overrides?: {\n    interface?: BaseConfig;\n    typeLiteral?: BaseConfig;\n  };\n  multilineDetection?: 'brackets' | 'last-member';\n};\n```\n\nDefault config:\n\n```json\n{\n  \"multiline\": {\n    \"delimiter\": \"semi\",\n    \"requireLast\": true\n  },\n  \"singleline\": {\n    \"delimiter\": \"semi\",\n    \"requireLast\": false\n  },\n  \"multilineDetection\": \"brackets\"\n}\n```\n\n`multiline` config only applies to multiline `interface`/`type` definitions.\n`singleline` config only applies to single line `interface`/`type` definitions.\nThe two configs are entirely separate, and do not effect one another.\n\n`multilineDetection` determines what counts as multiline\n\n- `\"brackets\"` (default) any newlines in the type or interface make it multiline.\n- `\"last-member\"` if the last member of the interface is on the same line as the last bracket, it is counted as a single line.\n\n### `delimiter`\n\nAccepts three values (or two for `singleline`):\n\n- `comma` - each member should be delimited with a comma (`,`).\n- `semi` - each member should be delimited with a semicolon (`;`).\n- `none` - each member should be delimited with nothing.\n\n:::note\n`none` is not an option for `singleline` because having no delimiter between members on a single line is a syntax error in TS.\n:::\n\n### `requireLast`\n\nDetermines whether or not the last member in the `interface`/`type` should have a delimiter:\n\n- `true` - the last member **_must_** have a delimiter.\n- `false` - the last member **_must not_** have a delimiter.\n\n### `overrides`\n\nAllows you to specify options specifically for either `interface`s or `type` definitions / inline `type`s.\n\nFor example, to require commas for `type`s, and semicolons for multiline `interface`s:\n\n```json\n{\n  \"multiline\": {\n    \"delimiter\": \"comma\",\n    \"requireLast\": true\n  },\n  \"singleline\": {\n    \"delimiter\": \"comma\",\n    \"requireLast\": true\n  },\n  \"overrides\": {\n    \"interface\": {\n      \"multiline\": {\n        \"delimiter\": \"semi\",\n        \"requireLast\": true\n      }\n    }\n  }\n}\n```\n\n## Examples\n\nExamples of code for this rule with the default config:\n\n<!--tabs-->\n\n### ‚ùå Incorrect\n\n<!-- prettier-ignore -->\n```ts\n// missing semicolon delimiter\ninterface Foo {\n    name: string\n    greet(): string\n}\n\n// using incorrect delimiter\ninterface Bar {\n    name: string,\n    greet(): string,\n}\n\n// missing last member delimiter\ninterface Baz {\n    name: string;\n    greet(): string\n}\n\n// incorrect delimiter\ntype FooBar = { name: string, greet(): string }\n\n// last member should not have delimiter\ntype FooBar = { name: string; greet(): string; }\n```\n\n### ‚úÖ Correct\n\n<!-- prettier-ignore -->\n```ts\ninterface Foo {\n    name: string;\n    greet(): string;\n}\n\ninterface Foo { name: string }\n\ntype Bar = {\n    name: string;\n    greet(): string;\n}\n\ntype Bar = { name: string }\n\ntype FooBar = { name: string; greet(): string }\n```\n\n## When Not To Use It\n\nIf you don't care about enforcing a consistent member delimiter in interfaces and type literals, then you will not need this rule.\n\n## Attributes\n\n- [ ] ‚úÖ Recommended\n- [x] üîß Fixable\n- [ ] üí≠ Requires type information\n"},"__N_SSG":true}