{"pageProps":{"rule":"# `strict-boolean-expressions`\n\nRestricts the types allowed in boolean expressions.\n\nForbids usage of non-boolean types in expressions where a boolean is expected.\n`boolean` and `never` types are always allowed.\nAdditional types which are considered safe in a boolean context can be configured via options.\n\nThe following nodes are considered boolean expressions and their type is checked:\n\n- Argument to the logical negation operator (`!arg`).\n- The condition in a conditional expression (`cond ? x : y`).\n- Conditions for `if`, `for`, `while`, and `do-while` statements.\n- Operands of logical binary operators (`lhs || rhs` and `lhs && rhs`).\n  - Right-hand side operand is ignored when it's not a descendant of another boolean expression.\n    This is to allow usage of boolean operators for their short-circuiting behavior.\n\n## Examples\n\nExamples of code for this rule:\n\n<!--tabs-->\n\n### ‚ùå Incorrect\n\n```ts\n// nullable numbers are considered unsafe by default\nlet num: number | undefined = 0;\nif (num) {\n  console.log('num is defined');\n}\n\n// nullable strings are considered unsafe by default\nlet str: string | null = null;\nif (!str) {\n  console.log('str is empty');\n}\n\n// nullable booleans are considered unsafe by default\nfunction foo(bool?: boolean) {\n  if (bool) {\n    bar();\n  }\n}\n\n// `any`, unconstrained generics and unions of more than one primitive type are disallowed\nconst foo = <T>(arg: T) => (arg ? 1 : 0);\n\n// always-truthy and always-falsy types are disallowed\nlet obj = {};\nwhile (obj) {\n  obj = getObj();\n}\n```\n\n### ‚úÖ Correct\n\n```tsx\n// Using logical operator short-circuiting is allowed\nconst Component = () => {\n  const entry = map.get('foo') || {};\n  return entry && <p>Name: {entry.name}</p>;\n};\n\n// nullable values should be checked explicitly against null or undefined\nlet num: number | undefined = 0;\nif (num != null) {\n  console.log('num is defined');\n}\n\nlet str: string | null = null;\nif (str != null && !str) {\n  console.log('str is empty');\n}\n\nfunction foo(bool?: boolean) {\n  if (bool ?? false) {\n    bar();\n  }\n}\n\n// `any` types should be cast to boolean explicitly\nconst foo = (arg: any) => (Boolean(arg) ? 1 : 0);\n```\n\n## Options\n\n```ts\ntype Options = {\n  allowString?: boolean;\n  allowNumber?: boolean;\n  allowNullableObject?: boolean;\n  allowNullableBoolean?: boolean;\n  allowNullableString?: boolean;\n  allowNullableNumber?: boolean;\n  allowAny?: boolean;\n};\n\nconst defaultOptions: Options = {\n  allowString: true,\n  allowNumber: true,\n  allowNullableObject: true,\n  allowNullableBoolean: false,\n  allowNullableString: false,\n  allowNullableNumber: false,\n  allowAny: false,\n  allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: false,\n};\n```\n\n### `allowString`\n\nAllows `string` in a boolean context.\nThis is safe because strings have only one falsy value (`\"\"`).\nSet this to `false` if you prefer the explicit `str != \"\"` or `str.length > 0` style.\n\n### `allowNumber`\n\nAllows `number` in a boolean context.\nThis is safe because numbers have only two falsy values (`0` and `NaN`).\nSet this to `false` if you prefer the explicit `num != 0` and `!Number.isNaN(num)` style.\n\n### `allowNullableObject`\n\nAllows `object | function | symbol | null | undefined` in a boolean context.\nThis is safe because objects, functions and symbols don't have falsy values.\nSet this to `false` if you prefer the explicit `obj != null` style.\n\n### `allowNullableBoolean`\n\nAllows `boolean | null | undefined` in a boolean context.\nThis is unsafe because nullable booleans can be either `false` or nullish.\nSet this to `false` if you want to enforce explicit `bool ?? false` or `bool ?? true` style.\nSet this to `true` if you don't mind implicitly treating false the same as a nullish value.\n\n### `allowNullableString`\n\nAllows `string | null | undefined` in a boolean context.\nThis is unsafe because nullable strings can be either an empty string or nullish.\nSet this to `true` if you don't mind implicitly treating an empty string the same as a nullish value.\n\n### `allowNullableNumber`\n\nAllows `number | null | undefined` in a boolean context.\nThis is unsafe because nullable numbers can be either a falsy number or nullish.\nSet this to `true` if you don't mind implicitly treating zero or NaN the same as a nullish value.\n\n### `allowAny`\n\nAllows `any` in a boolean context.\nThis is unsafe for obvious reasons.\nSet this to `true` at your own risk.\n\n### `allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing`\n\nIf this is set to `false`, then the rule will error on every file whose `tsconfig.json` does _not_ have the `strictNullChecks` compiler option (or `strict`) set to `true`.\n\nWithout `strictNullChecks`, TypeScript essentially erases `undefined` and `null` from the types. This means when this rule inspects the types from a variable, **it will not be able to tell that the variable might be `null` or `undefined`**, which essentially makes this rule a lot less useful.\n\nYou should be using `strictNullChecks` to ensure complete type-safety in your codebase.\n\nIf for some reason you cannot turn on `strictNullChecks`, but still want to use this rule - you can use this option to allow it - but know that the behavior of this rule is _undefined_ with the compiler option turned off. We will not accept bug reports if you are using this option.\n\n## Fixes and Suggestions\n\nThis rule provides following fixes and suggestions for particular types in boolean context:\n\n- `boolean` - Always allowed - no fix needed.\n- `string` - (when `allowString` is `false`) - Provides following suggestions:\n  - Change condition to check string's length (`str` ‚Üí `str.length > 0`)\n  - Change condition to check for empty string (`str` ‚Üí `str !== \"\"`)\n  - Explicitly cast value to a boolean (`str` ‚Üí `Boolean(str)`)\n- `number` - (when `allowNumber` is `false`):\n  - For `array.length` - Provides **autofix**:\n    - Change condition to check for 0 (`array.length` ‚Üí `array.length > 0`)\n  - For other number values - Provides following suggestions:\n    - Change condition to check for 0 (`num` ‚Üí `num !== 0`)\n    - Change condition to check for NaN (`num` ‚Üí `!Number.isNaN(num)`)\n    - Explicitly cast value to a boolean (`num` ‚Üí `Boolean(num)`)\n- `object | null | undefined` - (when `allowNullableObject` is `false`) - Provides **autofix**:\n  - Change condition to check for null/undefined (`maybeObj` ‚Üí `maybeObj != null`)\n- `boolean | null | undefined` - Provides following suggestions:\n  - Explicitly treat nullish value the same as false (`maybeBool` ‚Üí `maybeBool ?? false`)\n  - Change condition to check for true/false (`maybeBool` ‚Üí `maybeBool === true`)\n- `string | null | undefined` - Provides following suggestions:\n  - Change condition to check for null/undefined (`maybeStr` ‚Üí `maybeStr != null`)\n  - Explicitly treat nullish value the same as an empty string (`maybeStr` ‚Üí `maybeStr ?? \"\"`)\n  - Explicitly cast value to a boolean (`maybeStr` ‚Üí `Boolean(maybeStr)`)\n- `number | null | undefined` - Provides following suggestions:\n  - Change condition to check for null/undefined (`maybeNum` ‚Üí `maybeNum != null`)\n  - Explicitly treat nullish value the same as 0 (`maybeNum` ‚Üí `maybeNum ?? 0`)\n  - Explicitly cast value to a boolean (`maybeNum` ‚Üí `Boolean(maybeNum)`)\n- `any` and `unknown` - Provides following suggestions:\n  - Explicitly cast value to a boolean (`value` ‚Üí `Boolean(value)`)\n\n## Related To\n\n- TSLint: [strict-boolean-expressions](https://palantir.github.io/tslint/rules/strict-boolean-expressions)\n- [no-unnecessary-condition](./no-unnecessary-condition.md) - Similar rule which reports always-truthy and always-falsy values in conditions\n\n## Attributes\n\n- [ ] ‚úÖ Recommended\n- [x] üîß Fixable\n- [x] üí≠ Requires type information\n"},"__N_SSG":true}