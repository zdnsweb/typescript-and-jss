{"pageProps":{"rule":"# `no-unnecessary-type-constraint`\n\nDisallows unnecessary constraints on generic types.\n\n## Rule Details\n\nType parameters (`<T>`) may be \"constrained\" with an `extends` keyword ([docs](https://www.typescriptlang.org/docs/handbook/generics.html#generic-constraints)).\nWhen not provided, type parameters happen to default to:\n\n- As of TypeScript 3.9: `unknown` ([docs](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#type-parameters-that-extend-any-no-longer-act-as-any))\n- Before that, as of 3.5: `any` ([docs](https://devblogs.microsoft.com/typescript/announcing-typescript-3-5/#breaking-changes))\n\nIt is therefore redundant to `extend` from these types in later versions of TypeScript.\n\nExamples of code for this rule:\n\n<!--tabs-->\n\n### ‚ùå Incorrect\n\n```ts\ninterface FooAny<T extends any> {}\ninterface FooUnknown<T extends unknown> {}\n\ntype BarAny<T extends any> = {};\ntype BarUnknown<T extends unknown> = {};\n\nclass BazAny<T extends any> {\n  quxUnknown<U extends unknown>() {}\n}\n\nclass BazUnknown<T extends unknown> {\n  quxUnknown<U extends unknown>() {}\n}\n\nconst QuuxAny = <T extends any>() => {};\nconst QuuxUnknown = <T extends unknown>() => {};\n\nfunction QuuzAny<T extends any>() {}\nfunction QuuzUnknown<T extends unknown>() {}\n```\n\n### ‚úÖ Correct\n\n```ts\ninterface Foo<T> {}\n\ntype Bar<T> = {};\n\nclass Baz<T> {\n    qux<U> { }\n}\n\nconst Quux = <T>() => {};\n\nfunction Quuz<T>() {}\n```\n\n## Options\n\n```jsonc\n// .eslintrc.json\n{\n  \"rules\": {\n    \"@typescript-eslint/no-unnecessary-type-constraint\": \"error\"\n  }\n}\n```\n\nThis rule is not configurable.\n\n## When Not To Use It\n\nIf you don't care about the specific styles of your type constraints, or never use them in the first place, then you will not need this rule.\n\n## Attributes\n\n- [x] ‚úÖ Recommended\n- [x] üîß Fixable\n- [ ] üí≠ Requires type information\n"},"__N_SSG":true}