{"pageProps":{"rule":"# `class-literal-property-style`\n\nEnsures that literals on classes are exposed in a consistent style.\n\nWhen writing TypeScript applications, it's typically safe to store literal values on classes using fields with the `readonly` modifier to prevent them from being reassigned.\nWhen writing TypeScript libraries that could be used by JavaScript users however, it's typically safer to expose these literals using `getter`s, since the `readonly` modifier is enforced at compile type.\n\n## Rule Details\n\nThis rule aims to ensure that literals exposed by classes are done so consistently, in one of the two style described above.\nBy default this rule prefers the `fields` style as it means JS doesn't have to setup & teardown a function closure.\n\n:::note\n\nThis rule only checks for constant _literal_ values (string, template string, number, bigint, boolean, regexp, null). It does not check objects or arrays, because a readonly field behaves differently to a getter in those cases. It also does not check functions, as it is a common pattern to use readonly fields with arrow function values as auto-bound methods.\nThis is because these types can be mutated and carry with them more complex implications about their usage.\n\n:::\n\n### The `fields` style\n\nThis style checks for any getter methods that return literal values, and requires them to be defined using fields with the `readonly` modifier instead.\n\nExamples of code with the `fields` style:\n\n<!--tabs-->\n\n#### ‚ùå Incorrect\n\n```ts\n/* eslint @typescript-eslint/class-literal-property-style: [\"error\", \"fields\"] */\n\nclass Mx {\n  public static get myField1() {\n    return 1;\n  }\n\n  private get ['myField2']() {\n    return 'hello world';\n  }\n}\n```\n\n#### ‚úÖ Correct\n\n```ts\n/* eslint @typescript-eslint/class-literal-property-style: [\"error\", \"fields\"] */\n\nclass Mx {\n  public readonly myField1 = 1;\n\n  // not a literal\n  public readonly myField2 = [1, 2, 3];\n\n  private readonly ['myField3'] = 'hello world';\n\n  public get myField4() {\n    return `hello from ${window.location.href}`;\n  }\n}\n```\n\n### The `getters` style\n\nThis style checks for any `readonly` fields that are assigned literal values, and requires them to be defined as getters instead.\nThis style pairs well with the [`@typescript-eslint/prefer-readonly`](prefer-readonly.md) rule,\nas it will identify fields that can be `readonly`, and thus should be made into getters.\n\nExamples of code with the `getters` style:\n\n<!--tabs-->\n\n#### ‚ùå Incorrect\n\n```ts\n/* eslint @typescript-eslint/class-literal-property-style: [\"error\", \"getters\"] */\n\nclass Mx {\n  readonly myField1 = 1;\n  readonly myField2 = `hello world`;\n  private readonly myField3 = 'hello world';\n}\n```\n\n#### ‚úÖ Correct\n\n```ts\n/* eslint @typescript-eslint/class-literal-property-style: [\"error\", \"getters\"] */\n\nclass Mx {\n  // no readonly modifier\n  public myField1 = 'hello';\n\n  // not a literal\n  public readonly myField2 = [1, 2, 3];\n\n  public static get myField3() {\n    return 1;\n  }\n\n  private get ['myField4']() {\n    return 'hello world';\n  }\n}\n```\n\n## When Not To Use It\n\nWhen you have no strong preference, or do not wish to enforce a particular style\nfor how literal values are exposed by your classes.\n\n## Attributes\n\n- [ ] ‚úÖ Recommended\n- [x] üîß Fixable\n- [ ] üí≠ Requires type information\n"},"__N_SSG":true}