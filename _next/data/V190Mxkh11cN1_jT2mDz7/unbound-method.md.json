{"pageProps":{"rule":"# `unbound-method`\n\nEnforces unbound methods are called with their expected scope.\n\nWarns when a method is used outside of a method call.\n\nClass functions don't preserve the class scope when passed as standalone variables.\n\nIf your function does not access `this`, [you can annotate it with `this: void`](https://www.typescriptlang.org/docs/handbook/2/functions.html#declaring-this-in-a-function), or consider using an arrow function instead.\n\nIf you're working with `jest`, you can use [`eslint-plugin-jest`'s version of this rule](https://github.com/jest-community/eslint-plugin-jest/blob/main/docs/rules/unbound-method.md) to lint your test files, which knows when it's ok to pass an unbound method to `expect` calls.\n\n## Rule Details\n\nExamples of code for this rule\n\n<!--tabs-->\n\n### ❌ Incorrect\n\n```ts\nclass MyClass {\n  public log(): void {\n    console.log(this);\n  }\n}\n\nconst instance = new MyClass();\n\n// This logs the global scope (`window`/`global`), not the class instance\nconst myLog = instance.log;\nmyLog();\n\n// This log might later be called with an incorrect scope\nconst { log } = instance;\n\n// arith.double may refer to `this` internally\nconst arith = {\n  double(x: number): number {\n    return x * 2;\n  },\n};\nconst { double } = arith;\n```\n\n### ✅ Correct\n\n```ts\nclass MyClass {\n  public logUnbound(): void {\n    console.log(this);\n  }\n\n  public logBound = () => console.log(this);\n}\n\nconst instance = new MyClass();\n\n// logBound will always be bound with the correct scope\nconst { logBound } = instance;\nlogBound();\n\n// .bind and lambdas will also add a correct scope\nconst dotBindLog = instance.logBound.bind(instance);\nconst innerLog = () => instance.logBound();\n\n// arith.double explicitly declares that it does not refer to `this` internally\nconst arith = {\n  double(this: void, x: number): number {\n    return x * 2;\n  },\n};\nconst { double } = arith;\n```\n\n## Options\n\nThe rule accepts an options object with the following property:\n\n- `ignoreStatic` to not check whether `static` methods are correctly bound\n\n### `ignoreStatic`\n\nExamples of **correct** code for this rule with `{ ignoreStatic: true }`:\n\n```ts\nclass OtherClass {\n  static log() {\n    console.log(OtherClass);\n  }\n}\n\n// With `ignoreStatic`, statics are assumed to not rely on a particular scope\nconst { log } = OtherClass;\n\nlog();\n```\n\n## Example\n\n```json\n{\n  \"@typescript-eslint/unbound-method\": [\n    \"error\",\n    {\n      \"ignoreStatic\": true\n    }\n  ]\n}\n```\n\n## When Not To Use It\n\nIf your code intentionally waits to bind methods after use, such as by passing a `scope: this` along with the method, you can disable this rule.\n\nIf you're wanting to use `toBeCalled` and similar matches in `jest` tests, you can disable this rule for your test files in favor of [`eslint-plugin-jest`'s version of this rule](https://github.com/jest-community/eslint-plugin-jest/blob/main/docs/rules/unbound-method.md).\n\n## Related To\n\n- TSLint: [no-unbound-method](https://palantir.github.io/tslint/rules/no-unbound-method/)\n\n## Attributes\n\n- [x] ✅ Recommended\n- [ ] 🔧 Fixable\n- [x] 💭 Requires type information\n"},"__N_SSG":true}