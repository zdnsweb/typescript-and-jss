{"pageProps":{"rule":"# `member-ordering`\n\nRequire a consistent member declaration order.\n\nA consistent ordering of fields, methods and constructors can make interfaces, type literals, classes and class expressions easier to read, navigate and edit.\n\n## Rule Details\n\nThis rule aims to standardize the way class declarations, class expressions, interfaces and type literals are structured and ordered.\n\n### Grouping and sorting member groups\n\nIt allows to group members by their type (e.g. `public-static-field`, `protected-static-field`, `private-static-field`, `public-instance-field`, ...) and enforce a certain order for these groups. By default, their order is the same inside `classes`, `classExpressions`, `interfaces` and `typeLiterals` (note: not all member types apply to `interfaces` and `typeLiterals`). It is possible to define the order for any of those individually or to change the default order for all of them by setting the `default` option.\n\n### Sorting members\n\nBesides grouping the members and sorting their groups, this rule also allows to sort the members themselves (e.g. `a`, `b`, `c`, ...). You have 2 options: Sort all of them while ignoring their type or sort them while respecting their types (e.g. sort all fields in an interface alphabetically).\n\n## Options\n\nThese options allow to specify how to group the members and sort their groups.\n\n- Sort groups, don't enforce member order: Use `memberTypes`\n- Sort members, don't enforce group order: Use `order`\n- Sort members within groups: Use `memberTypes` and `order`\n\n```ts\ntype SortedOrderConfig = {\n  memberTypes?: MemberType[] | 'never';\n  order: 'alphabetically' | 'alphabetically-case-insensitive' | 'as-written';\n};\n\ntype OrderConfig = MemberType[] | SortedOrderConfig | 'never';\n\ntype Options = {\n  default?: OrderConfig;\n  classes?: OrderConfig;\n  classExpressions?: OrderConfig;\n  interfaces?: OrderConfig;\n  typeLiterals?: OrderConfig;\n};\n```\n\nSee below for the possible definitions of `MemberType`.\n\n### Deprecated syntax\n\nNote: There is a deprecated syntax to specify the member types as an array.\n\n### Member types (granular form)\n\nThere are multiple ways to specify the member types. The most explicit and granular form is the following:\n\n```jsonc\n[\n  // Index signature\n  \"signature\",\n\n  // Fields\n  \"public-static-field\",\n  \"protected-static-field\",\n  \"private-static-field\",\n  \"public-decorated-field\",\n  \"protected-decorated-field\",\n  \"private-decorated-field\",\n  \"public-instance-field\",\n  \"protected-instance-field\",\n  \"private-instance-field\",\n  \"public-abstract-field\",\n  \"protected-abstract-field\",\n  \"private-abstract-field\",\n\n  // Constructors\n  \"public-constructor\",\n  \"protected-constructor\",\n  \"private-constructor\",\n\n  // Getters\n  \"public-static-get\",\n  \"protected-static-get\",\n  \"private-static-get\",\n\n  \"public-decorated-get\",\n  \"protected-decorated-get\",\n  \"private-decorated-get\",\n\n  \"public-instance-get\",\n  \"protected-instance-get\",\n  \"private-instance-get\",\n\n  \"public-abstract-get\",\n  \"protected-abstract-get\",\n  \"private-abstract-get\",\n\n  \"public-get\",\n  \"protected-get\",\n  \"private-get\",\n\n  \"static-get\",\n  \"instance-get\",\n  \"abstract-get\",\n\n  \"decorated-get\",\n\n  \"get\",\n\n  // Setters\n  \"public-static-set\",\n  \"protected-static-set\",\n  \"private-static-set\",\n\n  \"public-decorated-set\",\n  \"protected-decorated-set\",\n  \"private-decorated-set\",\n\n  \"public-instance-set\",\n  \"protected-instance-set\",\n  \"private-instance-set\",\n\n  \"public-abstract-set\",\n  \"protected-abstract-set\",\n  \"private-abstract-set\",\n\n  \"public-set\",\n  \"protected-set\",\n  \"private-set\",\n\n  \"static-set\",\n  \"instance-set\",\n  \"abstract-set\",\n\n  \"decorated-set\",\n\n  \"set\",\n\n  // Methods\n  \"public-static-method\",\n  \"protected-static-method\",\n  \"private-static-method\",\n  \"public-decorated-method\",\n  \"protected-decorated-method\",\n  \"private-decorated-method\",\n  \"public-instance-method\",\n  \"protected-instance-method\",\n  \"private-instance-method\",\n  \"public-abstract-method\",\n  \"protected-abstract-method\",\n  \"private-abstract-method\"\n]\n```\n\nNote: If you only specify some of the possible types, the non-specified ones can have any particular order. This means that they can be placed before, within or after the specified types and the linter won't complain about it.\n\n### Member group types (with accessibility, ignoring scope)\n\nIt is also possible to group member types by their accessibility (`static`, `instance`, `abstract`), ignoring their scope.\n\n```jsonc\n[\n  // Index signature\n  // No accessibility for index signature. See above.\n\n  // Fields\n  \"public-field\", // = [\"public-static-field\", \"public-instance-field\"]\n  \"protected-field\", // = [\"protected-static-field\", \"protected-instance-field\"]\n  \"private-field\", // = [\"private-static-field\", \"private-instance-field\"]\n\n  // Constructors\n  // Only the accessibility of constructors is configurable. See below.\n\n  // Getters\n  \"public-get\", // = [\"public-static-get\", \"public-instance-get\"]\n  \"protected-get\", // = [\"protected-static-get\", \"protected-instance-get\"]\n  \"private-get\", // = [\"private-static-get\", \"private-instance-get\"]\n\n  // Setters\n  \"public-set\", // = [\"public-static-set\", \"public-instance-set\"]\n  \"protected-set\", // = [\"protected-static-set\", \"protected-instance-set\"]\n  \"private-set\", // = [\"private-static-set\", \"private-instance-set\"]\n\n  // Methods\n  \"public-method\", // = [\"public-static-method\", \"public-instance-method\"]\n  \"protected-method\", // = [\"protected-static-method\", \"protected-instance-method\"]\n  \"private-method\" // = [\"private-static-method\", \"private-instance-method\"]\n]\n```\n\n### Member group types (with accessibility and a decorator)\n\nIt is also possible to group methods or fields with a decorator separately, optionally specifying\ntheir accessibility.\n\n```jsonc\n[\n  // Index signature\n  // No decorators for index signature.\n\n  // Fields\n  \"public-decorated-field\",\n  \"protected-decorated-field\",\n  \"private-decorated-field\",\n\n  \"decorated-field\", // = [\"public-decorated-field\", \"protected-decorated-field\", \"private-decorated-field\"]\n\n  // Constructors\n  // There are no decorators for constructors.\n\n  // Getters\n  \"public-decorated-get\",\n  \"protected-decorated-get\",\n  \"private-decorated-get\",\n\n  \"decorated-get\" // = [\"public-decorated-get\", \"protected-decorated-get\", \"private-decorated-get\"]\n\n  // Setters\n  \"public-decorated-set\",\n  \"protected-decorated-set\",\n  \"private-decorated-set\",\n\n  \"decorated-set\" // = [\"public-decorated-set\", \"protected-decorated-set\", \"private-decorated-set\"]\n\n  // Methods\n  \"public-decorated-method\",\n  \"protected-decorated-method\",\n  \"private-decorated-method\",\n\n  \"decorated-method\" // = [\"public-decorated-method\", \"protected-decorated-method\", \"private-decorated-method\"]\n]\n```\n\n### Member group types (with scope, ignoring accessibility)\n\nAnother option is to group the member types by their scope (`public`, `protected`, `private`), ignoring their accessibility.\n\n```jsonc\n[\n  // Index signature\n  // No scope for index signature. See above.\n\n  // Fields\n  \"static-field\", // = [\"public-static-field\", \"protected-static-field\", \"private-static-field\"]\n  \"instance-field\", // = [\"public-instance-field\", \"protected-instance-field\", \"private-instance-field\"]\n  \"abstract-field\", // = [\"public-abstract-field\", \"protected-abstract-field\", \"private-abstract-field\"]\n\n  // Constructors\n  \"constructor\", // = [\"public-constructor\", \"protected-constructor\", \"private-constructor\"]\n\n  // Getters\n  \"static-get\", // = [\"public-static-get\", \"protected-static-get\", \"private-static-get\"]\n  \"instance-get\", // = [\"public-instance-get\", \"protected-instance-get\", \"private-instance-get\"]\n  \"abstract-get\" // = [\"public-abstract-get\", \"protected-abstract-get\", \"private-abstract-get\"]\n\n  // Setters\n  \"static-set\", // = [\"public-static-set\", \"protected-static-set\", \"private-static-set\"]\n  \"instance-set\", // = [\"public-instance-set\", \"protected-instance-set\", \"private-instance-set\"]\n  \"abstract-set\" // = [\"public-abstract-set\", \"protected-abstract-set\", \"private-abstract-set\"]\n\n  // Methods\n  \"static-method\", // = [\"public-static-method\", \"protected-static-method\", \"private-static-method\"]\n  \"instance-method\", // = [\"public-instance-method\", \"protected-instance-method\", \"private-instance-method\"]\n  \"abstract-method\" // = [\"public-abstract-method\", \"protected-abstract-method\", \"private-abstract-method\"]\n]\n```\n\n### Member group types (with scope and accessibility)\n\nThe third grouping option is to ignore both scope and accessibility.\n\n```jsonc\n[\n  // Index signature\n  // No grouping for index signature. See above.\n\n  // Fields\n  \"field\", // = [\"public-static-field\", \"protected-static-field\", \"private-static-field\", \"public-instance-field\", \"protected-instance-field\", \"private-instance-field\",\n  //              \"public-abstract-field\", \"protected-abstract-field\", private-abstract-field\"]\n\n  // Constructors\n  // Only the accessibility of constructors is configurable. See above.\n\n  // Getters\n  \"get\" // = [\"public-static-get\", \"protected-static-get\", \"private-static-get\", \"public-instance-get\", \"protected-instance-get\", \"private-instance-get\",\n  //                \"public-abstract-get\", \"protected-abstract-get\", \"private-abstract-get\"]\n\n  // Setters\n  \"set\" // = [\"public-static-set\", \"protected-static-set\", \"private-static-set\", \"public-instance-set\", \"protected-instance-set\", \"private-instance-set\",\n  //                \"public-abstract-set\", \"protected-abstract-set\", \"private-abstract-set\"]\n\n  // Methods\n  \"method\" // = [\"public-static-method\", \"protected-static-method\", \"private-static-method\", \"public-instance-method\", \"protected-instance-method\", \"private-instance-method\",\n  //                \"public-abstract-method\", \"protected-abstract-method\", \"private-abstract-method\"]\n]\n```\n\n### Grouping different member types at the same rank\n\nIt is also possible to group different member types at the same rank.\n\n```jsonc\n[\n  // Index signature\n  \"signature\",\n\n  // Fields\n  \"field\",\n\n  // Constructors\n  \"constructor\",\n\n  // Getters and Setters at the same rank\n  [\"get\", \"set\"],\n\n  // Methods\n  \"method\"\n]\n```\n\n### Default configuration\n\nThe default configuration looks as follows:\n\n```jsonc\n{\n  \"default\": [\n    // Index signature\n    \"signature\",\n\n    // Fields\n    \"public-static-field\",\n    \"protected-static-field\",\n    \"private-static-field\",\n\n    \"public-decorated-field\",\n    \"protected-decorated-field\",\n    \"private-decorated-field\",\n\n    \"public-instance-field\",\n    \"protected-instance-field\",\n    \"private-instance-field\",\n\n    \"public-abstract-field\",\n    \"protected-abstract-field\",\n    \"private-abstract-field\",\n\n    \"public-field\",\n    \"protected-field\",\n    \"private-field\",\n\n    \"static-field\",\n    \"instance-field\",\n    \"abstract-field\",\n\n    \"decorated-field\",\n\n    \"field\",\n\n    // Constructors\n    \"public-constructor\",\n    \"protected-constructor\",\n    \"private-constructor\",\n\n    \"constructor\",\n\n    // Getters\n    \"public-static-get\",\n    \"protected-static-get\",\n    \"private-static-get\",\n\n    \"public-decorated-get\",\n    \"protected-decorated-get\",\n    \"private-decorated-get\",\n\n    \"public-instance-get\",\n    \"protected-instance-get\",\n    \"private-instance-get\",\n\n    \"public-abstract-get\",\n    \"protected-abstract-get\",\n    \"private-abstract-get\",\n\n    \"public-get\",\n    \"protected-get\",\n    \"private-get\",\n\n    \"static-get\",\n    \"instance-get\",\n    \"abstract-get\",\n\n    \"decorated-get\",\n\n    \"get\",\n\n    // Setters\n    \"public-static-set\",\n    \"protected-static-set\",\n    \"private-static-set\",\n\n    \"public-decorated-set\",\n    \"protected-decorated-set\",\n    \"private-decorated-set\",\n\n    \"public-instance-set\",\n    \"protected-instance-set\",\n    \"private-instance-set\",\n\n    \"public-abstract-set\",\n    \"protected-abstract-set\",\n    \"private-abstract-set\",\n\n    \"public-set\",\n    \"protected-set\",\n    \"private-set\",\n\n    \"static-set\",\n    \"instance-set\",\n    \"abstract-set\",\n\n    \"decorated-set\",\n\n    \"set\",\n\n    // Methods\n    \"public-static-method\",\n    \"protected-static-method\",\n    \"private-static-method\",\n\n    \"public-decorated-method\",\n    \"protected-decorated-method\",\n    \"private-decorated-method\",\n\n    \"public-instance-method\",\n    \"protected-instance-method\",\n    \"private-instance-method\",\n\n    \"public-abstract-method\",\n    \"protected-abstract-method\",\n    \"private-abstract-method\",\n\n    \"public-method\",\n    \"protected-method\",\n    \"private-method\",\n\n    \"static-method\",\n    \"instance-method\",\n    \"abstract-method\",\n\n    \"decorated-method\",\n\n    \"method\"\n  ]\n}\n```\n\nNote: The default configuration contains member group types which contain other member types (see above). This is intentional to provide better error messages.\n\nNote: By default, the members are not sorted. If you want to sort them alphabetically, you have to provide a custom configuration.\n\n## Examples\n\n### Custom `default` configuration\n\nNote: The `default` options are overwritten in these examples.\n\n#### Configuration: `{ \"default\": [\"signature\", \"method\", \"constructor\", \"field\"] }`\n\n##### Incorrect examples\n\n```ts\ninterface Foo {\n  B: string; // -> field\n\n  new (); // -> constructor\n\n  A(): void; // -> method\n\n  [Z: string]: any; // -> signature\n}\n```\n\nNote: Wrong order.\n\n```ts\ntype Foo = {\n  B: string; // -> field\n\n  // no constructor\n\n  A(): void; // -> method\n\n  // no signature\n};\n```\n\nNote: Not all specified member types have to exist.\n\n```ts\nclass Foo {\n  private C: string; // -> field\n  public D: string; // -> field\n  protected static E: string; // -> field\n\n  constructor() {} // -> constructor\n\n  public static A(): void {} // -> method\n  public B(): void {} // -> method\n\n  [Z: string]: any; // -> signature\n}\n```\n\nNote: Accessibility or scope are ignored with this configuration.\n\n```ts\nconst Foo = class {\n  private C: string; // -> field\n  public D: string; // -> field\n\n  constructor() {} // -> constructor\n\n  public static A(): void {} // -> method\n  public B(): void {} // -> method\n\n  [Z: string]: any; // -> signature\n\n  protected static E: string; // -> field\n};\n```\n\nNote: Not all members have to be grouped to find rule violations.\n\n##### Correct examples\n\n```ts\ninterface Foo {\n  [Z: string]: any; // -> signature\n\n  A(): void; // -> method\n\n  new (); // -> constructor\n\n  B: string; // -> field\n}\n```\n\n```ts\ntype Foo = {\n  // no signature\n\n  A(): void; // -> method\n\n  // no constructor\n\n  B: string; // -> field\n};\n```\n\n```ts\nclass Foo {\n  [Z: string]: any; // -> signature\n\n  public static A(): void {} // -> method\n  public B(): void {} // -> method\n\n  constructor() {} // -> constructor\n\n  private C: string; // -> field\n  public D: string; // -> field\n  protected static E: string; // -> field\n}\n```\n\n```ts\nconst Foo = class {\n  [Z: string]: any; // -> signature\n\n  public static A(): void {} // -> method\n  public B(): void {} // -> method\n\n  constructor() {} // -> constructor\n\n  private C: string; // -> field\n  public D: string; // -> field\n  protected static E: string; // -> field\n};\n```\n\n#### Configuration: `{ \"default\": [\"public-instance-method\", \"public-static-field\"] }`\n\nNote: This configuration does not apply to interfaces/type literals as accessibility and scope are not part of interfaces/type literals.\n\n##### Incorrect examples\n\n```ts\nclass Foo {\n  private C: string; // (irrelevant)\n\n  public D: string; // (irrelevant)\n\n  public static E: string; // -> public static field\n\n  constructor() {} // (irrelevant)\n\n  public static A(): void {} // (irrelevant)\n\n  [Z: string]: any; // (irrelevant)\n\n  public B(): void {} // -> public instance method\n}\n```\n\nNote: Public instance methods should come first before public static fields. Everything else can be placed anywhere.\n\n```ts\nconst Foo = class {\n  private C: string; // (irrelevant)\n\n  [Z: string]: any; // (irrelevant)\n\n  public static E: string; // -> public static field\n\n  public D: string; // (irrelevant)\n\n  constructor() {} // (irrelevant)\n\n  public static A(): void {} // (irrelevant)\n\n  public B(): void {} // -> public instance method\n};\n```\n\nNote: Public instance methods should come first before public static fields. Everything else can be placed anywhere.\n\n##### Correct examples\n\n```ts\nclass Foo {\n  public B(): void {} // -> public instance method\n\n  private C: string; // (irrelevant)\n\n  public D: string; // (irrelevant)\n\n  public static E: string; // -> public static field\n\n  constructor() {} // (irrelevant)\n\n  public static A(): void {} // (irrelevant)\n\n  [Z: string]: any; // (irrelevant)\n}\n```\n\n```ts\nconst Foo = class {\n  public B(): void {} // -> public instance method\n\n  private C: string; // (irrelevant)\n\n  [Z: string]: any; // (irrelevant)\n\n  public D: string; // (irrelevant)\n\n  constructor() {} // (irrelevant)\n\n  public static A(): void {} // (irrelevant)\n\n  public static E: string; // -> public static field\n};\n```\n\n#### Configuration: `{ \"default\": [\"public-static-field\", \"static-field\", \"instance-field\"] }`\n\nNote: This configuration does not apply to interfaces/type literals as accessibility and scope are not part of interfaces/type literals.\n\n##### Incorrect examples\n\n```ts\nclass Foo {\n  private E: string; // -> instance field\n\n  private static B: string; // -> static field\n  protected static C: string; // -> static field\n  private static D: string; // -> static field\n\n  public static A: string; // -> public static field\n\n  [Z: string]: any; // (irrelevant)\n}\n```\n\nNote: Public static fields should come first, followed by static fields and instance fields.\n\n```ts\nconst foo = class {\n  public T(): void {} // (irrelevant)\n\n  private static B: string; // -> static field\n\n  constructor() {} // (irrelevant)\n\n  private E: string; // -> instance field\n\n  protected static C: string; // -> static field\n  private static D: string; // -> static field\n\n  [Z: string]: any; // (irrelevant)\n\n  public static A: string; // -> public static field\n};\n```\n\nNote: Public static fields should come first, followed by static fields and instance fields.\n\n##### Correct examples\n\n```ts\nclass Foo {\n  public static A: string; // -> public static field\n\n  private static B: string; // -> static field\n  protected static C: string; // -> static field\n  private static D: string; // -> static field\n\n  private E: string; // -> instance field\n}\n```\n\n```ts\nconst foo = class {\n  [Z: string]: any; // -> signature\n\n  public static A: string; // -> public static field\n\n  constructor() {} // -> constructor\n\n  private static B: string; // -> static field\n  protected static C: string; // -> static field\n  private static D: string; // -> static field\n\n  private E: string; // -> instance field\n\n  public T(): void {} // -> method\n};\n```\n\n### Custom `classes` configuration\n\nNote: If this is not set, the `default` will automatically be applied to classes as well. If a `classes` configuration is provided, only this configuration will be used for `classes` (i.e. nothing will be merged with `default`).\n\nNote: The configuration for `classes` does not apply to class expressions (use `classExpressions` for them).\n\n#### Configuration: `{ \"classes\": [\"method\", \"constructor\", \"field\"] }`\n\n##### Incorrect example\n\n```ts\nclass Foo {\n  private C: string; // -> field\n  public D: string; // -> field\n  protected static E: string; // -> field\n\n  constructor() {} // -> constructor\n\n  public static A(): void {} // -> method\n  public B(): void {} // -> method\n}\n```\n\n##### Correct example\n\n```ts\nclass Foo {\n  public static A(): void {} // -> method\n  public B(): void {} // -> method\n\n  constructor() {} // -> constructor\n\n  private C: string; // -> field\n  public D: string; // -> field\n  protected static E: string; // -> field\n}\n```\n\n#### Configuration: `{ \"classes\": [\"public-instance-method\", \"public-static-field\"] }`\n\n##### Incorrect example\n\n```ts\nclass Foo {\n  private C: string; // (irrelevant)\n\n  public D: string; // (irrelevant)\n\n  public static E: string; // -> public static field\n\n  constructor() {} // (irrelevant)\n\n  public static A(): void {} // (irrelevant)\n\n  public B(): void {} // -> public instance method\n}\n```\n\n##### Correct example\n\n```ts\nclass Foo {\n  private C: string; // (irrelevant)\n\n  public D: string; // (irrelevant)\n\n  public B(): void {} // -> public instance method\n\n  constructor() {} // (irrelevant)\n\n  public static A(): void {} // (irrelevant)\n\n  public static E: string; // -> public static field\n}\n```\n\n### Custom `classExpressions` configuration\n\nNote: If this is not set, the `default` will automatically be applied to classes expressions as well. If a `classExpressions` configuration is provided, only this configuration will be used for `classExpressions` (i.e. nothing will be merged with `default`).\n\nNote: The configuration for `classExpressions` does not apply to classes (use `classes` for them).\n\n#### Configuration: `{ \"classExpressions\": [\"method\", \"constructor\", \"field\"] }`\n\n##### Incorrect example\n\n```ts\nconst foo = class {\n  private C: string; // -> field\n  public D: string; // -> field\n  protected static E: string; // -> field\n\n  constructor() {} // -> constructor\n\n  public static A(): void {} // -> method\n  public B(): void {} // -> method\n};\n```\n\n##### Correct example\n\n```ts\nconst foo = class {\n  public static A(): void {} // -> method\n  public B(): void {} // -> method\n\n  constructor() {} // -> constructor\n\n  private C: string; // -> field\n  public D: string; // -> field\n  protected static E: string; // -> field\n};\n```\n\n#### Configuration: `{ \"classExpressions\": [\"public-instance-method\", \"public-static-field\"] }`\n\n##### Incorrect example\n\n```ts\nconst foo = class {\n  private C: string; // (irrelevant)\n\n  public D: string; // (irrelevant)\n\n  public static E: string; // -> public static field\n\n  constructor() {} // (irrelevant)\n\n  public static A(): void {} // (irrelevant)\n\n  public B(): void {} // -> public instance method\n};\n```\n\n##### Correct example\n\n```ts\nconst foo = class {\n  private C: string; // (irrelevant)\n\n  public D: string; // (irrelevant)\n\n  public B(): void {} // -> public instance method\n\n  public static E: string; // -> public static field\n\n  constructor() {} // (irrelevant)\n\n  public static A(): void {} // (irrelevant)\n};\n```\n\n### Custom `interfaces` configuration\n\nNote: If this is not set, the `default` will automatically be applied to classes expressions as well. If a `interfaces` configuration is provided, only this configuration will be used for `interfaces` (i.e. nothing will be merged with `default`).\n\nNote: The configuration for `interfaces` only allows a limited set of member types: `signature`, `field`, `constructor` and `method`.\n\nNote: The configuration for `interfaces` does not apply to type literals (use `typeLiterals` for them).\n\n#### Configuration: `{ \"interfaces\": [\"signature\", \"method\", \"constructor\", \"field\"] }`\n\n##### Incorrect example\n\n```ts\ninterface Foo {\n  B: string; // -> field\n\n  new (); // -> constructor\n\n  A(): void; // -> method\n\n  [Z: string]: any; // -> signature\n}\n```\n\n##### Correct example\n\n```ts\ninterface Foo {\n  [Z: string]: any; // -> signature\n\n  A(): void; // -> method\n\n  new (); // -> constructor\n\n  B: string; // -> field\n}\n```\n\n### Custom `typeLiterals` configuration\n\nNote: If this is not set, the `default` will automatically be applied to classes expressions as well. If a `typeLiterals` configuration is provided, only this configuration will be used for `typeLiterals` (i.e. nothing will be merged with `default`).\n\nNote: The configuration for `typeLiterals` only allows a limited set of member types: `signature`, `field`, `constructor` and `method`.\n\nNote: The configuration for `typeLiterals` does not apply to interfaces (use `interfaces` for them).\n\n#### Configuration: `{ \"typeLiterals\": [\"signature\", \"method\", \"constructor\", \"field\"] }`\n\n##### Incorrect example\n\n```ts\ntype Foo = {\n  B: string; // -> field\n\n  A(): void; // -> method\n\n  new (); // -> constructor\n\n  [Z: string]: any; // -> signature\n};\n```\n\n##### Correct example\n\n```ts\ntype Foo = {\n  [Z: string]: any; // -> signature\n\n  A(): void; // -> method\n\n  new (); // -> constructor\n\n  B: string; // -> field\n};\n```\n\n### Sorting alphabetically within member groups\n\nIt is possible to sort all members within a group alphabetically.\n\n#### Configuration: `{ \"default\": { \"memberTypes\": <Default Order>, \"order\": \"alphabetically\" } }`\n\nThis will apply the default order (see above) and enforce an alphabetic case-sensitive order within each group.\n\n##### Incorrect examples\n\n```ts\ninterface Foo {\n  B: x;\n  a: x;\n  c: x;\n\n  new (): Bar;\n  (): Baz;\n\n  B(): void;\n  a(): void;\n  c(): void;\n\n  // Wrong group order, should be placed before all field definitions\n  [a: string]: number;\n}\n```\n\n```ts\ninterface Foo {\n  [a: string]: number;\n\n  B: x;\n  a: x;\n  c: x;\n\n  new (): Bar;\n  (): Baz;\n\n  // Wrong alphabetic order within group\n  c(): void;\n  B(): void;\n  a(): void;\n}\n```\n\n### Sorting alphabetically while ignoring member groups\n\nIt is also possible to sort all members and ignore the member groups completely.\n\n#### Configuration: `{ \"default\": { \"memberTypes\": \"never\", \"order\": \"alphabetically\" } }`\n\n##### Incorrect example\n\n```ts\ninterface Foo {\n  b(): void;\n  a: b;\n\n  [a: string]: number; // Order doesn't matter (no sortable identifier)\n  new (): Bar; // Order doesn't matter (no sortable identifier)\n  (): Baz; // Order doesn't matter (no sortable identifier)\n}\n```\n\nNote: Wrong alphabetic order `b(): void` should come after `a: b`.\n\n### Sorting alphabetically case-insensitive within member groups\n\nIt is possible to sort all members within a group alphabetically with case insensitivity.\n\n#### Configuration: `{ \"default\": { \"memberTypes\": <Default Order>, \"order\": \"alphabetically-case-insensitive\" } }`\n\nThis will apply the default order (see above) and enforce an alphabetic case-insensitive order within each group.\n\n##### Incorrect examples\n\n```ts\ninterface Foo {\n  a: x;\n  B: x;\n  c: x;\n\n  new (): Bar;\n  (): Baz;\n\n  a(): void;\n  b(): void;\n  C(): void;\n\n  // Wrong group order, should be placed before all field definitions\n  [a: string]: number;\n}\n```\n\n```ts\ninterface Foo {\n  [a: string]: number;\n\n  a: x;\n  B: x;\n  c: x;\n\n  new (): Bar;\n  (): Baz;\n\n  // Wrong alphabetic order within group\n  C(): void;\n  b(): void;\n  a(): void;\n}\n```\n\n### Sorting alphabetically case-insensitive while ignoring member groups\n\nIt is also possible to sort all members with case insensitivity and ignore the member groups completely.\n\n#### Configuration: `{ \"default\": { \"memberTypes\": \"never\", \"order\": \"alphabetically-case-insensitive\" } }`\n\n##### Incorrect example\n\n```ts\ninterface Foo {\n  B(): void;\n  a: number;\n\n  [a: string]: number; // Order doesn't matter (no sortable identifier)\n  new (): Bar; // Order doesn't matter (no sortable identifier)\n  (): Baz; // Order doesn't matter (no sortable identifier)\n}\n```\n\nNote: Wrong alphabetic order `B(): void` should come after `a: number`.\n\n## When Not To Use It\n\nIf you don't care about the general structure of your classes and interfaces, then you will not need this rule.\n\n## Related To\n\n- TSLint: [member-ordering](https://palantir.github.io/tslint/rules/member-ordering/)\n\n## Attributes\n\n- [ ] ✅ Recommended\n- [ ] 🔧 Fixable\n- [ ] 💭 Requires type information\n"},"__N_SSG":true}