{"pageProps":{"rule":"# `sort-type-union-intersection-members`\n\nEnforces that members of a type union/intersection are sorted alphabetically.\n\nSorting union (`|`) and intersection (`&`) types can help:\n\n- keep your codebase standardized\n- find repeated types\n- reduce diff churn\n\n## Rule Details\n\nSorting within each group is done using the following code:\n\n```ts\nconst collator = new Intl.Collator('en', {\n  sensitivity: 'base',\n  numeric: true,\n});\n\nfunction compare(a, b) {\n  return collator.compare(a, b) || (a < b ? -1 : a > b ? 1 : 0);\n}\n```\n\nIn other words, the types are sorted alphabetically, case-insensitively and treating numbers like a human would, falling back to character code sorting in case of ties.\n\nExamples of code for this rule:\n\n<!--tabs-->\n\n### âŒ Incorrect\n\n```ts\ntype T1 = B | A;\n\ntype T2 = { b: string } & { a: string };\n\ntype T3 = [1, 2, 4] & [1, 2, 3];\n\ntype T4 =\n  | [1, 2, 4]\n  | [1, 2, 3]\n  | { b: string }\n  | { a: string }\n  | (() => void)\n  | (() => string)\n  | 'b'\n  | 'a'\n  | 'b'\n  | 'a'\n  | readonly string[]\n  | readonly number[]\n  | string[]\n  | number[]\n  | B\n  | A\n  | string\n  | any;\n```\n\n### âœ… Correct\n\n```ts\ntype T1 = A | B;\n\ntype T2 = { a: string } & { b: string };\n\ntype T3 = [1, 2, 3] & [1, 2, 4];\n\ntype T4 =\n  | any\n  | string\n  | A\n  | B\n  | number[]\n  | string[]\n  | readonly number[]\n  | readonly string[]\n  | 'a'\n  | 'b'\n  | 'a'\n  | 'b'\n  | (() => string)\n  | (() => void)\n  | { a: string }\n  | { b: string }\n  | [1, 2, 3]\n  | [1, 2, 4];\n```\n\n## Options\n\n```ts\ntype Options = {\n  // true to check intersection types, false otherwise\n  checkIntersections?: boolean;\n  // true to check union types, false otherwise\n  checkUnions?: boolean;\n  // the ordering of the groups\n  groupOrder?: (\n    | 'conditional'\n    | 'function'\n    | 'import'\n    | 'intersection'\n    | 'keyword'\n    | 'literal'\n    | 'named'\n    | 'object'\n    | 'operator'\n    | 'tuple'\n    | 'union'\n    | 'nullish'\n  )[];\n};\n\nconst defaultOptions: Options = {\n  checkIntersections: true,\n  checkUnions: true,\n  groupOrder: [\n    'named',\n    'keyword',\n    'operator',\n    'literal',\n    'function',\n    'import',\n    'conditional',\n    'object',\n    'tuple',\n    'intersection',\n    'union',\n    'nullish',\n  ],\n};\n```\n\n### `groupOrder`\n\nEach member of the type is placed into a group, and then the rule sorts alphabetically within each group.\nThe ordering of groups is determined by this option.\n\n- `conditional` - Conditional types (`A extends B ? C : D`)\n- `function` - Function and constructor types (`() => void`, `new () => type`)\n- `import` - Import types (`import('path')`)\n- `intersection` - Intersection types (`A & B`)\n- `keyword` - Keyword types (`any`, `string`, etc)\n- `literal` - Literal types (`1`, `'b'`, `true`, etc)\n- `named` - Named types (`A`, `A['prop']`, `B[]`, `Array<C>`)\n- `object` - Object types (`{ a: string }`, `{ [key: string]: number }`)\n- `operator` - Operator types (`keyof A`, `typeof B`, `readonly C[]`)\n- `tuple` - Tuple types (`[A, B, C]`)\n- `union` - Union types (`A | B`)\n- `nullish` - `null` and `undefined`\n\n## Attributes\n\n- [ ] âœ… Recommended\n- [x] ðŸ”§ Fixable\n- [ ] ðŸ’­ Requires type information\n"},"__N_SSG":true}