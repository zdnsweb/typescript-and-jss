{"pageProps":{"rule":"# `typedef`\n\nRequires type annotations to exist.\n\nTypeScript cannot always infer types for all places in code.\nSome locations require type annotations for their types to be inferred.\n\n```ts\nclass ContainsText {\n  // There must be a type annotation here to infer the type\n  delayedText: string;\n\n  // `typedef` requires a type annotation here to maintain consistency\n  immediateTextExplicit: string = 'text';\n\n  // This is still a string type because of its initial value\n  immediateTextImplicit = 'text';\n}\n```\n\n**_Note:_** requiring type annotations unnecessarily can be cumbersome to maintain and generally reduces code readability.\nTypeScript is often better at inferring types than easily written type annotations would allow.\n\n**Instead of enabling `typedef`, it is generally recommended to use the `--noImplicitAny` and `--strictPropertyInitialization` compiler options to enforce type annotations only when useful.**\n\n## Rule Details\n\nThis rule can enforce type annotations in locations regardless of whether they're required.\nThis is typically used to maintain consistency for element types that sometimes require them.\n\n> To enforce type definitions existing on call signatures as per TSLint's `arrow-call-signature` and `call-signature` options, use `explicit-function-return-type`, or `explicit-module-boundary-types`.\n\n## Options\n\n```ts\ntype Options = {\n  arrayDestructuring?: boolean;\n  arrowParameter?: boolean;\n  memberVariableDeclaration?: boolean;\n  objectDestructuring?: boolean;\n  parameter?: boolean;\n  propertyDeclaration?: boolean;\n  variableDeclaration?: boolean;\n  variableDeclarationIgnoreFunction?: boolean;\n};\n\nconst defaultOptions: Options = {\n  arrayDestructuring: false,\n  arrowParameter: false,\n  memberVariableDeclaration: false,\n  objectDestructuring: false,\n  parameter: false,\n  propertyDeclaration: false,\n  variableDeclaration: false,\n  variableDeclarationIgnoreFunction: false,\n};\n```\n\nFor example, with the following configuration:\n\n```json\n{\n  \"rules\": {\n    \"@typescript-eslint/typedef\": [\n      \"error\",\n      {\n        \"arrowParameter\": true,\n        \"variableDeclaration\": true\n      }\n    ]\n  }\n}\n```\n\n- Type annotations on arrow function parameters are required\n- Type annotations on variables are required\n\n### `arrayDestructuring`\n\nWhether to enforce type annotations on variables declared using array destructuring.\n\nExamples of code with `{ \"arrayDestructuring\": true }`:\n\n<!--tabs-->\n\n#### ‚ùå Incorrect\n\n```ts\nconst [a] = [1];\nconst [b, c] = [1, 2];\n```\n\n#### ‚úÖ Correct\n\n```ts\nconst [a]: number[] = [1];\nconst [b]: [number] = [2];\nconst [c, d]: [boolean, string] = [true, 'text'];\n\nfor (const [key, val] of new Map([['key', 1]])) {\n}\n```\n\n### `arrowParameter`\n\nWhether to enforce type annotations for parameters of arrow functions.\n\nExamples of code with `{ \"arrowParameter\": true }`:\n\n<!--tabs-->\n\n#### ‚ùå Incorrect\n\n```ts\nconst logsSize = size => console.log(size);\n\n['hello', 'world'].map(text => text.length);\n\nconst mapper = {\n  map: text => text + '...',\n};\n```\n\n#### ‚úÖ Correct\n\n```ts\nconst logsSize = (size: number) => console.log(size);\n\n['hello', 'world'].map((text: string) => text.length);\n\nconst mapper = {\n  map: (text: string) => text + '...',\n};\n```\n\n### `memberVariableDeclaration`\n\nWhether to enforce type annotations on member variables of classes.\n\nExamples of code with `{ \"memberVariableDeclaration\": true }`:\n\n<!--tabs-->\n\n#### ‚ùå Incorrect\n\n```ts\nclass ContainsText {\n  delayedText;\n  immediateTextImplicit = 'text';\n}\n```\n\n#### ‚úÖ Correct\n\n```ts\nclass ContainsText {\n  delayedText: string;\n  immediateTextImplicit: string = 'text';\n}\n```\n\n### `objectDestructuring`\n\nWhether to enforce type annotations on variables declared using object destructuring.\n\nExamples of code with `{ \"objectDestructuring\": true }`:\n\n<!--tabs-->\n\n#### ‚ùå Incorrect\n\n```ts\nconst { length } = 'text';\nconst [b, c] = Math.random() ? [1, 2] : [3, 4];\n```\n\n#### ‚úÖ Correct\n\n```ts\nconst { length }: { length: number } = 'text';\nconst [b, c]: [number, number] = Math.random() ? [1, 2] : [3, 4];\n\nfor (const { key, val } of [{ key: 'key', val: 1 }]) {\n}\n```\n\n### `parameter`\n\nWhether to enforce type annotations for parameters of functions and methods.\n\nExamples of code with `{ \"parameter\": true }`:\n\n<!--tabs-->\n\n#### ‚ùå Incorrect\n\n```ts\nfunction logsSize(size): void {\n  console.log(size);\n}\n\nconst doublesSize = function (size): number {\n  return size * 2;\n};\n\nconst divider = {\n  curriesSize(size): number {\n    return size;\n  },\n  dividesSize: function (size): number {\n    return size / 2;\n  },\n};\n\nclass Logger {\n  log(text): boolean {\n    console.log('>', text);\n    return true;\n  }\n}\n```\n\n#### ‚úÖ Correct\n\n```ts\nfunction logsSize(size: number): void {\n  console.log(size);\n}\n\nconst doublesSize = function (size: number): number {\n  return size * 2;\n};\n\nconst divider = {\n  curriesSize(size: number): number {\n    return size;\n  },\n  dividesSize: function (size: number): number {\n    return size / 2;\n  },\n};\n\nclass Logger {\n  log(text: boolean): boolean {\n    console.log('>', text);\n    return true;\n  }\n}\n```\n\n### `propertyDeclaration`\n\nWhether to enforce type annotations for properties of interfaces and types.\n\nExamples of code with `{ \"propertyDeclaration\": true }`:\n\n<!--tabs-->\n\n#### ‚ùå Incorrect\n\n```ts\ntype Members = {\n  member;\n  otherMember;\n};\n```\n\n#### ‚úÖ Correct\n\n```ts\ntype Members = {\n  member: boolean;\n  otherMember: string;\n};\n```\n\n### `variableDeclaration`\n\nWhether to enforce type annotations for variable declarations, excluding array and object destructuring.\n\nExamples of code with `{ \"variableDeclaration\": true }`:\n\n<!--tabs-->\n\n#### ‚ùå Incorrect\n\n```ts\nconst text = 'text';\nlet initialText = 'text';\nlet delayedText;\n```\n\n#### ‚úÖ Correct\n\n```ts\nconst text: string = 'text';\nlet initialText: string = 'text';\nlet delayedText: string;\n```\n\n### `variableDeclarationIgnoreFunction`\n\nIgnore variable declarations for non-arrow and arrow functions.\n\nExamples of code with `{ \"variableDeclaration\": true, \"variableDeclarationIgnoreFunction\": true }`:\n\n<!--tabs-->\n\n#### ‚ùå Incorrect\n\n```ts\nconst text = 'text';\n```\n\n#### ‚úÖ Correct\n\n```ts\nconst a = (): void => {};\nconst b = function (): void => {};\nconst c: () => void = (): void => {};\n\nclass Foo {\n  a = (): void => {};\n  b = function (): void => {};\n  c = () => void = (): void => {};\n}\n```\n\n## When Not To Use It\n\nIf you are using stricter TypeScript compiler options, particularly `--noImplicitAny` and/or `--strictPropertyInitialization`, you likely don't need this rule.\n\nIn general, if you do not consider the cost of writing unnecessary type annotations reasonable, then do not use this rule.\n\n## Further Reading\n\n- [TypeScript Type System](https://basarat.gitbooks.io/typescript/docs/types/type-system.html)\n- [Type Inference](https://www.typescriptlang.org/docs/handbook/type-inference.html)\n\n## Related To\n\n- TSLint: [`typedef`](https://palantir.github.io/tslint/rules/typedef)\n\n## Attributes\n\n- [ ] ‚úÖ Recommended\n- [ ] üîß Fixable\n- [ ] üí≠ Requires type information\n"},"__N_SSG":true}