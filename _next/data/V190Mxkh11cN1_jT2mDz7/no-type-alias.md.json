{"pageProps":{"rule":"# `no-type-alias`\n\nDisallow the use of type aliases.\n\nIn TypeScript, type aliases serve three purposes:\n\n- Aliasing other types so that we can refer to them using a simpler name.\n\n```ts\n// this...\ntype Person = {\n    firstName: string,\n    lastName: string,\n    age: number\n};\n\nfunction addPerson(person : Person) { ... }\n\n// is easier to read than this...\nfunction addPerson(person : { firstName: string, lastName: string, age: number}) { ... }\n```\n\n- Act sort of like an interface, providing a set of methods and properties that must exist\n  in the objects implementing the type.\n\n```ts\ntype Person = {\n    firstName: string,\n    lastName: string,\n    age: number,\n    walk: () => void,\n    talk: () => void\n};\n\n// you know person will have 3 properties and 2 methods,\n// because the structure has already been defined.\nvar person : Person = { ... }\n\n// so we can be sure that this will work\nperson.walk();\n```\n\n- Act like mapping tools between types to allow quick modifications.\n\n```ts\ntype Immutable<T> = { readonly [P in keyof T]: T[P] };\n\ntype Person = {\n  name: string;\n  age: number;\n};\n\ntype ImmutablePerson = Immutable<Person>;\n\nvar person: ImmutablePerson = { name: 'John', age: 30 };\nperson.name = 'Brad'; // error, readonly property\n```\n\nWhen aliasing, the type alias does not create a new type, it just creates a new name\nto refer to the original type. So aliasing primitives and other simple types, tuples, unions\nor intersections can some times be redundant.\n\n```ts\n// this doesn't make much sense\ntype myString = string;\n```\n\nOn the other hand, using a type alias as an interface can limit your ability to:\n\n- Reuse your code: interfaces can be extended or implemented by other types. Type aliases cannot.\n- Debug your code: interfaces create a new name, so is easy to identify the base type of an object\n  while debugging the application.\n\nFinally, mapping types is an advanced technique and leaving it open can quickly become a pain point\nin your application.\n\n## Rule Details\n\nThis rule disallows the use of type aliases in favor of interfaces\nand simplified types (primitives, tuples, unions, intersections, etc).\n\n## Options\n\nThis rule, in its default state, does not require any argument. If you would like to enable one\nor more of the following you may pass an object with the options set as follows:\n\n- `allowAliases` set to `\"always\"` will allow you to do aliasing (Defaults to `\"never\"`).\n- `allowCallbacks` set to `\"always\"` will allow you to use type aliases with callbacks (Defaults to `\"never\"`)\n- `allowConditionalTypes` set to `\"always\"` will allow you to use type aliases with conditional types (Defaults to `\"never\"`)\n- `allowConstructors` set to `\"always\"` will allow you to use type aliases with constructors (Defaults to `\"never\"`)\n- `allowLiterals` set to `\"always\"` will allow you to use type aliases with literal objects (Defaults to `\"never\"`)\n- `allowMappedTypes` set to `\"always\"` will allow you to use type aliases as mapping tools (Defaults to `\"never\"`)\n- `allowTupleTypes` set to `\"always\"` will allow you to use type aliases with tuples (Defaults to `\"never\"`)\n- `allowGenerics` set to `\"always\"` will allow you to use type aliases with generics (Defaults to `\"never\"`)\n\n### `allowAliases`\n\nThis applies to primitive types and reference types.\n\nThe setting accepts the following values:\n\n- `\"always\"` or `\"never\"` to active or deactivate the feature.\n- `\"in-unions\"`, allows aliasing in union statements, e.g. `type Foo = string | string[];`\n- `\"in-intersections\"`, allows aliasing in intersection statements, e.g. `type Foo = string & string[];`\n- `\"in-unions-and-intersections\"`, allows aliasing in union and/or intersection statements.\n\nExamples of **correct** code for the `{ \"allowAliases\": \"always\" }` options:\n\n```ts\n// primitives\ntype Foo = 'a';\n\ntype Foo = 'a' | 'b';\n\ntype Foo = string;\n\ntype Foo = string | string[];\n\ntype Foo = string & string[];\n\n// reference types\ninterface Bar {}\nclass Baz implements Bar {}\n\ntype Foo = Bar;\n\ntype Foo = Bar | Baz;\n\ntype Foo = Bar & Baz;\n```\n\nExamples of **incorrect** code for the `{ \"allowAliases\": \"in-unions\" }` option:\n\n```ts\n// primitives\ntype Foo = 'a';\n\ntype Foo = string;\n\ntype Foo = string & string[];\n\n// reference types\ninterface Bar {}\nclass Baz implements Bar {}\n\ntype Foo = Bar;\n\ntype Foo = Bar & Baz;\n```\n\nExamples of **correct** code for the `{ \"allowAliases\": \"in-unions\" }` option:\n\n```ts\n// primitives\ntype Foo = 'a' | 'b';\n\ntype Foo = string | string[];\n\n// reference types\ninterface Bar {}\nclass Baz implements Bar {}\n\ntype Foo = Bar | Baz;\n```\n\nExamples of **incorrect** code for the `{ \"allowAliases\": \"in-intersections\" }` option:\n\n```ts\n// primitives\ntype Foo = 'a';\n\ntype Foo = 'a' | 'b';\n\ntype Foo = string;\n\ntype Foo = string | string[];\n\n// reference types\ninterface Bar {}\nclass Baz implements Bar {}\n\ntype Foo = Bar;\n\ntype Foo = Bar | Baz;\n```\n\nExamples of **correct** code for the `{ \"allowAliases\": \"in-intersections\" }` option:\n\n```ts\n// primitives\ntype Foo = string & string[];\n\n// reference types\ninterface Bar {}\nclass Baz implements Bar {}\n\ntype Foo = Bar & Baz;\n```\n\nExamples of **incorrect** code for the `{ \"allowAliases\": \"in-unions-and-intersections\" }` option:\n\n```ts\n// primitives\ntype Foo = 'a';\n\ntype Foo = string;\n\n// reference types\ninterface Bar {}\nclass Baz implements Bar {}\n\ntype Foo = Bar;\n```\n\nExamples of **correct** code for the `{ \"allowAliases\": \"in-unions-and-intersections\" }` option:\n\n```ts\n// primitives\ntype Foo = 'a' | 'b';\n\ntype Foo = string | string[];\n\ntype Foo = string & string[];\n\n// reference types\ninterface Bar {}\nclass Baz implements Bar {}\n\ntype Foo = Bar | Baz;\n\ntype Foo = Bar & Baz;\n```\n\n### `allowCallbacks`\n\nThis applies to function types.\n\nThe setting accepts the following values:\n\n- `\"always\"` or `\"never\"` to active or deactivate the feature.\n\nExamples of **correct** code for the `{ \"allowCallbacks\": \"always\" }` option:\n\n```ts\ntype Foo = () => void;\n\ntype Foo = (name: string) => string;\n\nclass Person {}\n\ntype Foo = (name: string, age: number) => string | Person;\n\ntype Foo = (name: string, age: number) => string & Person;\n```\n\n### `allowConditionalTypes`\n\nThis applies to conditional types.\n\nExamples of **correct** code for the `{ \"allowConditionalTypes\": \"always\" }` option:\n\n```ts\ntype Foo<T> = T extends number ? number : null;\n```\n\n### `allowConstructors`\n\nThis applies to constructor types.\n\nThe setting accepts the following values:\n\n- `\"always\"` or `\"never\"` to active or deactivate the feature.\n\nExamples of **correct** code for the `{ \"allowConstructors\": \"always\" }` option:\n\n```ts\ntype Foo = new () => void;\n```\n\n### `allowLiterals`\n\nThis applies to literal types (`type Foo = { ... }`).\n\nThe setting accepts the following options:\n\n- `\"always\"` or `\"never\"` to active or deactivate the feature.\n- `\"in-unions\"`, allows literals in union statements, e.g. `type Foo = string | string[];`\n- `\"in-intersections\"`, allows literals in intersection statements, e.g. `type Foo = string & string[];`\n- `\"in-unions-and-intersections\"`, allows literals in union and/or intersection statements.\n\nExamples of **correct** code for the `{ \"allowLiterals\": \"always\" }` options:\n\n```ts\ntype Foo = {};\n\ntype Foo = {\n  name: string;\n  age: number;\n};\n\ntype Foo = {\n  name: string;\n  age: number;\n  walk: (miles: number) => void;\n};\n\ntype Foo = { name: string } | { age: number };\n\ntype Foo = { name: string } & { age: number };\n```\n\nExamples of **incorrect** code for the `{ \"allowLiterals\": \"in-unions\" }` option:\n\n```ts\ntype Foo = {};\n\ntype Foo = {\n  name: string;\n  age: number;\n};\n\ntype Foo = {\n  name: string;\n  age: number;\n  walk: (miles: number) => void;\n};\n\ntype Foo = { name: string } & { age: number };\n```\n\nExamples of **correct** code for the `{ \"allowLiterals\": \"in-unions\" }` option:\n\n```ts\ntype Foo = { name: string } | { age: number };\n```\n\nExamples of **incorrect** code for the `{ \"allowLiterals\": \"in-intersections\" }` option:\n\n```ts\ntype Foo = {};\n\ntype Foo = {\n  name: string;\n  age: number;\n};\n\ntype Foo = {\n  name: string;\n  age: number;\n  walk: (miles: number) => void;\n};\n\ntype Foo = { name: string } | { age: number };\n```\n\nExamples of **correct** code for the `{ \"allowLiterals\": \"in-intersections\" }` option:\n\n```ts\ntype Foo = { name: string } & { age: number };\n```\n\nExamples of **incorrect** code for the `{ \"allowLiterals\": \"in-unions-and-intersections\" }` option:\n\n```ts\ntype Foo = {};\n\ntype Foo = {\n  name: string;\n  age: number;\n};\n\ntype Foo = {\n  name: string;\n  age: number;\n  walk: (miles: number) => void;\n};\n```\n\nExamples of **correct** code for the `{ \"allowLiterals\": \"in-unions-and-intersections\" }` option:\n\n```ts\ntype Foo = { name: string } | { age: number };\n\ntype Foo = { name: string } & { age: number };\n```\n\n### `allowMappedTypes`\n\nThis applies to literal types.\n\nThe setting accepts the following values:\n\n- `\"always\"` or `\"never\"` to active or deactivate the feature.\n- `\"in-unions\"`, allows aliasing in union statements, e.g. `type Foo = string | string[];`\n- `\"in-intersections\"`, allows aliasing in intersection statements, e.g. `type Foo = string & string[];`\n- `\"in-unions-and-intersections\"`, allows aliasing in union and/or intersection statements.\n\nExamples of **correct** code for the `{ \"allowMappedTypes\": \"always\" }` options:\n\n```ts\ntype Foo<T> = { readonly [P in keyof T]: T[P] };\n\ntype Foo<T> = { [P in keyof T]?: T[P] };\n\ntype Foo<T, U> =\n  | { readonly [P in keyof T]: T[P] }\n  | { readonly [P in keyof U]: U[P] };\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } | { [P in keyof U]?: U[P] };\n\ntype Foo<T, U> = { readonly [P in keyof T]: T[P] } & {\n  readonly [P in keyof U]: U[P];\n};\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } & { [P in keyof U]?: U[P] };\n```\n\nExamples of **incorrect** code for the `{ \"allowMappedTypes\": \"in-unions\" }` option:\n\n```ts\ntype Foo<T> = { readonly [P in keyof T]: T[P] };\n\ntype Foo<T> = { [P in keyof T]?: T[P] };\n\ntype Foo<T, U> = { readonly [P in keyof T]: T[P] } & {\n  readonly [P in keyof U]: U[P];\n};\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } & { [P in keyof U]?: U[P] };\n```\n\nExamples of **correct** code for the `{ \"allowMappedTypes\": \"in-unions\" }` option:\n\n```ts\ntype Foo<T, U> =\n  | { readonly [P in keyof T]: T[P] }\n  | { readonly [P in keyof U]: U[P] };\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } | { [P in keyof U]?: U[P] };\n```\n\nExamples of **incorrect** code for the `{ \"allowMappedTypes\": \"in-intersections\" }` option:\n\n```ts\ntype Foo<T> = { readonly [P in keyof T]: T[P] };\n\ntype Foo<T> = { [P in keyof T]?: T[P] };\n\ntype Foo<T, U> =\n  | { readonly [P in keyof T]: T[P] }\n  | { readonly [P in keyof U]: U[P] };\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } | { [P in keyof U]?: U[P] };\n```\n\nExamples of **correct** code for the `{ \"allowMappedTypes\": \"in-intersections\" }` option:\n\n```ts\ntype Foo<T, U> = { readonly [P in keyof T]: T[P] } & {\n  readonly [P in keyof U]: U[P];\n};\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } & { [P in keyof U]?: U[P] };\n```\n\nExamples of **incorrect** code for the `{ \"allowMappedTypes\": \"in-unions-and-intersections\" }` option:\n\n```ts\ntype Foo<T> = { readonly [P in keyof T]: T[P] };\n\ntype Foo<T> = { [P in keyof T]?: T[P] };\n```\n\nExamples of **correct** code for the `{ \"allowMappedTypes\": \"in-unions-and-intersections\" }` option:\n\n```ts\ntype Foo<T, U> =\n  | { readonly [P in keyof T]: T[P] }\n  | { readonly [P in keyof U]: U[P] };\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } | { [P in keyof U]?: U[P] };\n\ntype Foo<T, U> = { readonly [P in keyof T]: T[P] } & {\n  readonly [P in keyof U]: U[P];\n};\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } & { [P in keyof U]?: U[P] };\n```\n\n### `allowTupleTypes`\n\nThis applies to tuple types (`type Foo = [number]`).\n\nThe setting accepts the following options:\n\n- `\"always\"` or `\"never\"` to active or deactivate the feature.\n- `\"in-unions\"`, allows tuples in union statements, e.g. `type Foo = [string] | [string, string];`\n- `\"in-intersections\"`, allows tuples in intersection statements, e.g. `type Foo = [string] & [string, string];`\n- `\"in-unions-and-intersections\"`, allows tuples in union and/or intersection statements.\n\nExamples of **correct** code for the `{ \"allowTupleTypes\": \"always\" }` options:\n\n```ts\ntype Foo = [number];\n\ntype Foo = [number] | [number, number];\n\ntype Foo = [number] & [number, number];\n\ntype Foo = [number] | ([number, number] & [string, string]);\n```\n\nExamples of **incorrect** code for the `{ \"allowTupleTypes\": \"in-unions\" }` option:\n\n```ts\ntype Foo = [number];\n\ntype Foo = [number] & [number, number];\n\ntype Foo = [string] & [number];\n```\n\nExamples of **correct** code for the `{ \"allowTupleTypes\": \"in-unions\" }` option:\n\n```ts\ntype Foo = [number] | [number, number];\n\ntype Foo = [string] | [number];\n```\n\nExamples of **incorrect** code for the `{ \"allowTupleTypes\": \"in-intersections\" }` option:\n\n```ts\ntype Foo = [number];\n\ntype Foo = [number] | [number, number];\n\ntype Foo = [string] | [number];\n```\n\nExamples of **correct** code for the `{ \"allowTupleTypes\": \"in-intersections\" }` option:\n\n```ts\ntype Foo = [number] & [number, number];\n\ntype Foo = [string] & [number];\n```\n\nExamples of **incorrect** code for the `{ \"allowTupleTypes\": \"in-unions-and-intersections\" }` option:\n\n```ts\ntype Foo = [number];\n\ntype Foo = [string];\n```\n\nExamples of **correct** code for the `{ \"allowLiterals\": \"in-unions-and-intersections\" }` option:\n\n```ts\ntype Foo = [number] & [number, number];\n\ntype Foo = [string] | [number];\n```\n\n### `allowGenerics`\n\nThis applies to generic types, including TypeScript provided global utility types (`type Foo = Record<string, number>`).\n\nThe setting accepts the following options:\n\n- `\"always\"` or `\"never\"` to active or deactivate the feature.\n\nExamples of **correct** code for the `{ \"allowGenerics\": \"always\" }` options:\n\n```ts\ntype Foo = Bar<string>;\n\ntype Foo = Record<string, number>;\n\ntype Foo = Readonly<Bar>;\n\ntype Foo = Partial<Bar>;\n\ntype Foo = Omit<Bar, 'a' | 'b'>;\n```\n\n## When Not To Use It\n\nWhen you can't express some shape with an interface or you need to use a union, tuple type,\ncallback, etc. that would cause the code to be unreadable or impractical.\n\n## Further Reading\n\n- [Advance Types](https://www.typescriptlang.org/docs/handbook/advanced-types.html)\n\n## Related To\n\n- TSLint: [interface-over-type-literal](https://palantir.github.io/tslint/rules/interface-over-type-literal/)\n\n## Attributes\n\n- [ ] âœ… Recommended\n- [ ] ðŸ”§ Fixable\n- [ ] ðŸ’­ Requires type information\n"},"__N_SSG":true}