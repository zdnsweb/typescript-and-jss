{"pageProps":{"rule":"# `no-inferrable-types`\n\nDisallows explicit type declarations for variables or parameters initialized to a number, string, or boolean.\n\nExplicit types where they can be easily inferred may add unnecessary verbosity.\n\n## Rule Details\n\nThis rule disallows explicit type declarations on parameters, variables\nand properties where the type can be easily inferred from its value.\n\n## Options\n\nThis rule accepts the following options:\n\n```ts\ninterface Options {\n  ignoreParameters?: boolean;\n  ignoreProperties?: boolean;\n}\n```\n\n### Default\n\nThe default options are:\n\n```json\n{\n  \"ignoreParameters\": false,\n  \"ignoreProperties\": false\n}\n```\n\nWith these options, the following patterns are:\n\n<!--tabs-->\n\n#### ‚ùå Incorrect\n\n```ts\nconst a: bigint = 10n;\nconst a: bigint = -10n;\nconst a: bigint = BigInt(10);\nconst a: bigint = -BigInt(10);\nconst a: boolean = false;\nconst a: boolean = true;\nconst a: boolean = Boolean(null);\nconst a: boolean = !0;\nconst a: number = 10;\nconst a: number = +10;\nconst a: number = -10;\nconst a: number = Number('1');\nconst a: number = +Number('1');\nconst a: number = -Number('1');\nconst a: number = Infinity;\nconst a: number = +Infinity;\nconst a: number = -Infinity;\nconst a: number = NaN;\nconst a: number = +NaN;\nconst a: number = -NaN;\nconst a: null = null;\nconst a: RegExp = /a/;\nconst a: RegExp = RegExp('a');\nconst a: RegExp = new RegExp('a');\nconst a: string = 'str';\nconst a: string = `str`;\nconst a: string = String(1);\nconst a: symbol = Symbol('a');\nconst a: undefined = undefined;\nconst a: undefined = void someValue;\n\nclass Foo {\n  prop: number = 5;\n}\n\nfunction fn(a: number = 5, b: boolean = true) {}\n```\n\n#### ‚úÖ Correct\n\n```ts\nconst a = 10n;\nconst a = -10n;\nconst a = BigInt(10);\nconst a = -BigInt(10);\nconst a = false;\nconst a = true;\nconst a = Boolean(null);\nconst a = !0;\nconst a = 10;\nconst a = +10;\nconst a = -10;\nconst a = Number('1');\nconst a = +Number('1');\nconst a = -Number('1');\nconst a = Infinity;\nconst a = +Infinity;\nconst a = -Infinity;\nconst a = NaN;\nconst a = +NaN;\nconst a = -NaN;\nconst a = null;\nconst a = /a/;\nconst a = RegExp('a');\nconst a = new RegExp('a');\nconst a = 'str';\nconst a = `str`;\nconst a = String(1);\nconst a = Symbol('a');\nconst a = undefined;\nconst a = void someValue;\n\nclass Foo {\n  prop = 5;\n}\n\nfunction fn(a = 5, b = true) {}\n\nfunction fn(a: number, b: boolean, c: string) {}\n```\n\n<!--/tabs-->\n\n### `ignoreParameters`\n\nWhen set to true, the following pattern is considered valid:\n\n```ts\nfunction foo(a: number = 5, b: boolean = true) {\n  // ...\n}\n```\n\n### `ignoreProperties`\n\nWhen set to true, the following pattern is considered valid:\n\n```ts\nclass Foo {\n  prop: number = 5;\n}\n```\n\n## When Not To Use It\n\nIf you do not want to enforce inferred types.\n\n## Further Reading\n\nTypeScript [Inference](https://www.typescriptlang.org/docs/handbook/type-inference.html)\n\n## Related To\n\nTSLint: [no-inferrable-types](https://palantir.github.io/tslint/rules/no-inferrable-types/)\n\n## Attributes\n\n- [x] ‚úÖ Recommended\n- [x] üîß Fixable\n- [ ] üí≠ Requires type information\n"},"__N_SSG":true}